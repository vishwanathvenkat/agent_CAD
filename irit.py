# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _irit
else:
    import _irit

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def new_doubleArray(nelements):
    return _irit.new_doubleArray(nelements)

def delete_doubleArray(ary):
    return _irit.delete_doubleArray(ary)

def doubleArray_getitem(ary, index):
    return _irit.doubleArray_getitem(ary, index)

def doubleArray_setitem(ary, index, value):
    return _irit.doubleArray_setitem(ary, index, value)
class intArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _irit.intArray_swiginit(self, _irit.new_intArray(nelements))
    __swig_destroy__ = _irit.delete_intArray

    def __getitem__(self, index):
        return _irit.intArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _irit.intArray___setitem__(self, index, value)

    def cast(self):
        return _irit.intArray_cast(self)

    @staticmethod
    def frompointer(t):
        return _irit.intArray_frompointer(t)

# Register intArray in _irit:
_irit.intArray_swigregister(intArray)
class IPObjectStruct(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Pnext = property(_irit.IPObjectStruct_Pnext_get, _irit.IPObjectStruct_Pnext_set)
    Attr = property(_irit.IPObjectStruct_Attr_get, _irit.IPObjectStruct_Attr_set)
    Dpnds = property(_irit.IPObjectStruct_Dpnds_get, _irit.IPObjectStruct_Dpnds_set)
    Count = property(_irit.IPObjectStruct_Count_get, _irit.IPObjectStruct_Count_set)
    Tags = property(_irit.IPObjectStruct_Tags_get, _irit.IPObjectStruct_Tags_set)
    ObjType = property(_irit.IPObjectStruct_ObjType_get, _irit.IPObjectStruct_ObjType_set)
    BBox = property(_irit.IPObjectStruct_BBox_get, _irit.IPObjectStruct_BBox_set)
    U = property(_irit.IPObjectStruct_U_get)
    ObjName = property(_irit.IPObjectStruct_ObjName_get, _irit.IPObjectStruct_ObjName_set)

    def __str__(self):
        return _irit.IPObjectStruct___str__(self)

    def __eq__(self, right):
        return _irit.IPObjectStruct___eq__(self, right)

    def __ne__(self, right):
        return _irit.IPObjectStruct___ne__(self, right)

    def __gt__(self, right):
        return _irit.IPObjectStruct___gt__(self, right)

    def __lt__(self, right):
        return _irit.IPObjectStruct___lt__(self, right)

    def __ge__(self, right):
        return _irit.IPObjectStruct___ge__(self, right)

    def __le__(self, right):
        return _irit.IPObjectStruct___le__(self, right)

    def __add__(self, *args):
        return _irit.IPObjectStruct___add__(self, *args)

    def __sub__(self, *args):
        return _irit.IPObjectStruct___sub__(self, *args)

    def __mul__(self, *args):
        return _irit.IPObjectStruct___mul__(self, *args)

    def __div__(self, *args):
        return _irit.IPObjectStruct___div__(self, *args)

    def __xor__(self, *args):
        return _irit.IPObjectStruct___xor__(self, *args)

    def __neg__(self):
        return _irit.IPObjectStruct___neg__(self)

    def __init__(self):
        _irit.IPObjectStruct_swiginit(self, _irit.new_IPObjectStruct())
    __swig_destroy__ = _irit.delete_IPObjectStruct

# Register IPObjectStruct in _irit:
_irit.IPObjectStruct_swigregister(IPObjectStruct)
class IPObjectStruct_U(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Pl = property(_irit.IPObjectStruct_U_Pl_get, _irit.IPObjectStruct_U_Pl_set)
    Crvs = property(_irit.IPObjectStruct_U_Crvs_get, _irit.IPObjectStruct_U_Crvs_set)
    Srfs = property(_irit.IPObjectStruct_U_Srfs_get, _irit.IPObjectStruct_U_Srfs_set)
    TrimSrfs = property(_irit.IPObjectStruct_U_TrimSrfs_get, _irit.IPObjectStruct_U_TrimSrfs_set)
    Trivars = property(_irit.IPObjectStruct_U_Trivars_get, _irit.IPObjectStruct_U_Trivars_set)
    TriSrfs = property(_irit.IPObjectStruct_U_TriSrfs_get, _irit.IPObjectStruct_U_TriSrfs_set)
    Instance = property(_irit.IPObjectStruct_U_Instance_get, _irit.IPObjectStruct_U_Instance_set)
    Mdls = property(_irit.IPObjectStruct_U_Mdls_get, _irit.IPObjectStruct_U_Mdls_set)
    MultiVars = property(_irit.IPObjectStruct_U_MultiVars_get, _irit.IPObjectStruct_U_MultiVars_set)
    R = property(_irit.IPObjectStruct_U_R_get, _irit.IPObjectStruct_U_R_set)
    Pt = property(_irit.IPObjectStruct_U_Pt_get, _irit.IPObjectStruct_U_Pt_set)
    Vec = property(_irit.IPObjectStruct_U_Vec_get, _irit.IPObjectStruct_U_Vec_set)
    Plane = property(_irit.IPObjectStruct_U_Plane_get, _irit.IPObjectStruct_U_Plane_set)
    CtlPt = property(_irit.IPObjectStruct_U_CtlPt_get, _irit.IPObjectStruct_U_CtlPt_set)
    Mat = property(_irit.IPObjectStruct_U_Mat_get, _irit.IPObjectStruct_U_Mat_set)
    Lst = property(_irit.IPObjectStruct_U_Lst_get)
    Str = property(_irit.IPObjectStruct_U_Str_get, _irit.IPObjectStruct_U_Str_set)
    VPtr = property(_irit.IPObjectStruct_U_VPtr_get, _irit.IPObjectStruct_U_VPtr_set)

    def __init__(self):
        _irit.IPObjectStruct_U_swiginit(self, _irit.new_IPObjectStruct_U())
    __swig_destroy__ = _irit.delete_IPObjectStruct_U

# Register IPObjectStruct_U in _irit:
_irit.IPObjectStruct_U_swigregister(IPObjectStruct_U)
class IPObjectStruct_U_Lst(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PObjList = property(_irit.IPObjectStruct_U_Lst_PObjList_get, _irit.IPObjectStruct_U_Lst_PObjList_set)
    ListMaxLen = property(_irit.IPObjectStruct_U_Lst_ListMaxLen_get, _irit.IPObjectStruct_U_Lst_ListMaxLen_set)

    def __init__(self):
        _irit.IPObjectStruct_U_Lst_swiginit(self, _irit.new_IPObjectStruct_U_Lst())
    __swig_destroy__ = _irit.delete_IPObjectStruct_U_Lst

# Register IPObjectStruct_U_Lst in _irit:
_irit.IPObjectStruct_U_Lst_swigregister(IPObjectStruct_U_Lst)
IP_OBJ_UNDEF = _irit.IP_OBJ_UNDEF
IP_OBJ_POLY = _irit.IP_OBJ_POLY
IP_OBJ_NUMERIC = _irit.IP_OBJ_NUMERIC
IP_OBJ_POINT = _irit.IP_OBJ_POINT
IP_OBJ_VECTOR = _irit.IP_OBJ_VECTOR
IP_OBJ_PLANE = _irit.IP_OBJ_PLANE
IP_OBJ_MATRIX = _irit.IP_OBJ_MATRIX
IP_OBJ_CURVE = _irit.IP_OBJ_CURVE
IP_OBJ_SURFACE = _irit.IP_OBJ_SURFACE
IP_OBJ_STRING = _irit.IP_OBJ_STRING
IP_OBJ_LIST_OBJ = _irit.IP_OBJ_LIST_OBJ
IP_OBJ_CTLPT = _irit.IP_OBJ_CTLPT
IP_OBJ_TRIMSRF = _irit.IP_OBJ_TRIMSRF
IP_OBJ_TRIVAR = _irit.IP_OBJ_TRIVAR
IP_OBJ_INSTANCE = _irit.IP_OBJ_INSTANCE
IP_OBJ_TRISRF = _irit.IP_OBJ_TRISRF
IP_OBJ_MODEL = _irit.IP_OBJ_MODEL
IP_OBJ_MULTIVAR = _irit.IP_OBJ_MULTIVAR
IP_OBJ_ANY = _irit.IP_OBJ_ANY
PI = _irit.PI
ON = _irit.ON
TRUE = _irit.TRUE
OFF = _irit.OFF
FALSE = _irit.FALSE
COL = _irit.COL
ROW = _irit.ROW
DEPTH = _irit.DEPTH
CLIENTS_ALL = _irit.CLIENTS_ALL
KV_OPEN = _irit.KV_OPEN
KV_DISC_OPEN = _irit.KV_DISC_OPEN
KV_FLOAT = _irit.KV_FLOAT
KV_PERIODIC = _irit.KV_PERIODIC
PARAM_NIELFOL = _irit.PARAM_NIELFOL
PARAM_CHORD = _irit.PARAM_CHORD
PARAM_CENTRIP = _irit.PARAM_CENTRIP
PARAM_UNIFORM = _irit.PARAM_UNIFORM
E1 = _irit.E1
E2 = _irit.E2
E3 = _irit.E3
E4 = _irit.E4
E5 = _irit.E5
E6 = _irit.E6
E7 = _irit.E7
E8 = _irit.E8
E9 = _irit.E9
P1 = _irit.P1
P2 = _irit.P2
P3 = _irit.P3
P4 = _irit.P4
P5 = _irit.P5
P6 = _irit.P6
P7 = _irit.P7
P8 = _irit.P8
P9 = _irit.P9
UNDEF_TYPE = _irit.UNDEF_TYPE
POLY_TYPE = _irit.POLY_TYPE
NUMERIC_TYPE = _irit.NUMERIC_TYPE
POINT_TYPE = _irit.POINT_TYPE
VECTOR_TYPE = _irit.VECTOR_TYPE
PLANE_TYPE = _irit.PLANE_TYPE
MATRIX_TYPE = _irit.MATRIX_TYPE
CURVE_TYPE = _irit.CURVE_TYPE
SURFACE_TYPE = _irit.SURFACE_TYPE
STRING_TYPE = _irit.STRING_TYPE
CTLPT_TYPE = _irit.CTLPT_TYPE
LIST_TYPE = _irit.LIST_TYPE
TRIVAR_TYPE = _irit.TRIVAR_TYPE
TRISRF_TYPE = _irit.TRISRF_TYPE
TRIMSRF_TYPE = _irit.TRIMSRF_TYPE
MODEL_TYPE = _irit.MODEL_TYPE
MULTIVAR_TYPE = _irit.MULTIVAR_TYPE
VMODEL_TYPE = _irit.VMODEL_TYPE
BEZIER_TYPE = _irit.BEZIER_TYPE
BSPLINE_TYPE = _irit.BSPLINE_TYPE
POWER_TYPE = _irit.POWER_TYPE
GREGORY_TYPE = _irit.GREGORY_TYPE
UNTRIMMED_TYPE = _irit.UNTRIMMED_TYPE
GEOM_CONST = _irit.GEOM_CONST
GEOM_LINEAR = _irit.GEOM_LINEAR
GEOM_CIRCULAR = _irit.GEOM_CIRCULAR
GEOM_PLANAR = _irit.GEOM_PLANAR
GEOM_SPHERICAL = _irit.GEOM_SPHERICAL
GEOM_SRF_OF_REV = _irit.GEOM_SRF_OF_REV
GEOM_EXTRUSION = _irit.GEOM_EXTRUSION
GEOM_RULED_SRF = _irit.GEOM_RULED_SRF
GEOM_DEVELOP_SRF = _irit.GEOM_DEVELOP_SRF
GEOM_SWEEP = _irit.GEOM_SWEEP
BLACK = _irit.BLACK
BLUE = _irit.BLUE
GREEN = _irit.GREEN
CYAN = _irit.CYAN
RED = _irit.RED
MAGENTA = _irit.MAGENTA
YELLOW = _irit.YELLOW
WHITE = _irit.WHITE
MSDOS = _irit.MSDOS
SGI = _irit.SGI
HP = _irit.HP
APOLLO = _irit.APOLLO
SUN = _irit.SUN
UNIX = _irit.UNIX
IBMOS2 = _irit.IBMOS2
WINDOWS = _irit.WINDOWS
AMIGA = _irit.AMIGA
CYGWIN = _irit.CYGWIN
MACOSX = _irit.MACOSX
LINUX = _irit.LINUX

def write_stdout(Line):
    return _irit.write_stdout(Line)

def write_stderr(Line):
    return _irit.write_stderr(Line)

def _set_stdout(Func):
    return _irit._set_stdout(Func)

def _set_stderr(Func):
    return _irit._set_stderr(Func)

def cpoly(Param1):
    return _irit.cpoly(Param1)

def area(Param1):
    return _irit.area(Param1)

def volume(Param1):
    return _irit.volume(Param1)

def time(Param1):
    return _irit.time(Param1)

def SizeOf(Param1):
    return _irit.SizeOf(Param1)

def meshsize(Param1, Param2):
    return _irit.meshsize(Param1, Param2)

def thisobj(Param1):
    return _irit.thisobj(Param1)

def random(Param1, Param2):
    return _irit.random(Param1, Param2)

def clntexec(Param1):
    return _irit.clntexec(Param1)

def dstptln(Param1, Param2, Param3):
    return _irit.dstptln(Param1, Param2, Param3)

def dstptpln(Param1, Param2):
    return _irit.dstptpln(Param1, Param2)

def dstlnln(Param1, Param2, Param3, Param4):
    return _irit.dstlnln(Param1, Param2, Param3, Param4)

def zcollide(Param1, Param2, Param3, Param4):
    return _irit.zcollide(Param1, Param2, Param3, Param4)

def hausdrpts(Param1, Param2, Param3):
    return _irit.hausdrpts(Param1, Param2, Param3)

def point(arg1, arg2, arg3):
    return _irit.point(arg1, arg2, arg3)

def vector(arg1, arg2, arg3):
    return _irit.vector(arg1, arg2, arg3)

def plane(arg1, arg2, arg3, arg4):
    return _irit.plane(arg1, arg2, arg3, arg4)

def rotx(INPUT):
    return _irit.rotx(INPUT)

def roty(INPUT):
    return _irit.roty(INPUT)

def rotz(INPUT):
    return _irit.rotz(INPUT)

def rotvec(Param1, INPUT):
    return _irit.rotvec(Param1, INPUT)

def rotz2v2(Param1, Param2):
    return _irit.rotz2v2(Param1, Param2)

def rotz2v(Param1):
    return _irit.rotz2v(Param1)

def rotv2v(Param1, Param2):
    return _irit.rotv2v(Param1, Param2)

def map3pt2eql(Param1, Param2, Param3):
    return _irit.map3pt2eql(Param1, Param2, Param3)

def trans(Param1):
    return _irit.trans(Param1)

def scale(Param1):
    return _irit.scale(Param1)

def box(Param1, arg2, arg3, arg4):
    return _irit.box(Param1, arg2, arg3, arg4)

def gbox(Param1, Param2, Param3, Param4):
    return _irit.gbox(Param1, Param2, Param3, Param4)

def cone(Param1, Param2, arg3, arg4):
    return _irit.cone(Param1, Param2, arg3, arg4)

def con2(Param1, Param2, arg3, arg4, arg5):
    return _irit.con2(Param1, Param2, arg3, arg4, arg5)

def cylin(Param1, Param2, arg3, arg4):
    return _irit.cylin(Param1, Param2, arg3, arg4)

def sphere(Param1, INPUT):
    return _irit.sphere(Param1, INPUT)

def torus(Param1, Param2, arg3, arg4):
    return _irit.torus(Param1, Param2, arg3, arg4)

def circpoly(Param1, Param2, INPUT):
    return _irit.circpoly(Param1, Param2, INPUT)

def poly(Param1, INPUT):
    return _irit.poly(Param1, INPUT)

def polyholes(Param1, Param2):
    return _irit.polyholes(Param1, Param2)

def crossec(Param1):
    return _irit.crossec(Param1)

def surfrev(Param1):
    return _irit.surfrev(Param1)

def surfrevaxs(Param1, Param2):
    return _irit.surfrevaxs(Param1, Param2)

def surfrev2(Param1, arg2, arg3):
    return _irit.surfrev2(Param1, arg2, arg3)

def surfrevax2(Param1, arg2, arg3, Param4):
    return _irit.surfrevax2(Param1, arg2, arg3, Param4)

def surfprev(Param1):
    return _irit.surfprev(Param1)

def surfprev2(Param1, arg2, arg3):
    return _irit.surfprev2(Param1, arg2, arg3)

def extrude(Param1, Param2, INPUT):
    return _irit.extrude(Param1, Param2, INPUT)

def ztextrude(Param1, arg2, arg3):
    return _irit.ztextrude(Param1, arg2, arg3)

def load(Param1):
    return _irit.load(Param1)

def convex(Param1):
    return _irit.convex(Param1)

def spower(Param1):
    return _irit.spower(Param1)

def cpower(Param1):
    return _irit.cpower(Param1)

def sbezier(Param1):
    return _irit.sbezier(Param1)

def cbezier(Param1):
    return _irit.cbezier(Param1)

def sbspline(arg1, arg2, Param3, Param4):
    return _irit.sbspline(arg1, arg2, Param3, Param4)

def cbspline(INPUT, Param2, Param3):
    return _irit.cbspline(INPUT, Param2, Param3)

def crvbuild(INPUT, Param2):
    return _irit.crvbuild(INPUT, Param2)

def seval(Param1, arg2, arg3):
    return _irit.seval(Param1, arg2, arg3)

def ceval(Param1, INPUT):
    return _irit.ceval(Param1, INPUT)

def stangent(Param1, arg2, arg3, arg4, arg5):
    return _irit.stangent(Param1, arg2, arg3, arg4, arg5)

def ctangent(Param1, arg2, arg3):
    return _irit.ctangent(Param1, arg2, arg3)

def pnormal(Param1, INPUT, Param3):
    return _irit.pnormal(Param1, INPUT, Param3)

def pattrib(Param1, INPUT, Param3, Param4):
    return _irit.pattrib(Param1, INPUT, Param3, Param4)

def snormal(Param1, arg2, arg3):
    return _irit.snormal(Param1, arg2, arg3)

def tsnormal(Param1, arg2, arg3, arg4):
    return _irit.tsnormal(Param1, arg2, arg3, arg4)

def cnormal(Param1, INPUT):
    return _irit.cnormal(Param1, INPUT)

def mdivide(Param1, arg2, arg3):
    return _irit.mdivide(Param1, arg2, arg3)

def tdivide(Param1, arg2, arg3):
    return _irit.tdivide(Param1, arg2, arg3)

def sdivide(Param1, arg2, arg3):
    return _irit.sdivide(Param1, arg2, arg3)

def sdivcrv(Param1, Param2):
    return _irit.sdivcrv(Param1, Param2)

def cdivide(Param1, INPUT):
    return _irit.cdivide(Param1, INPUT)

def mregion(Param1, arg2, arg3, arg4):
    return _irit.mregion(Param1, arg2, arg3, arg4)

def tregion(Param1, arg2, arg3, arg4):
    return _irit.tregion(Param1, arg2, arg3, arg4)

def sregion(Param1, arg2, arg3, arg4):
    return _irit.sregion(Param1, arg2, arg3, arg4)

def cregion(Param1, arg2, arg3):
    return _irit.cregion(Param1, arg2, arg3)

def mrefine(Param1, arg2, arg3, Param4):
    return _irit.mrefine(Param1, arg2, arg3, Param4)

def trefine(Param1, arg2, arg3, Param4):
    return _irit.trefine(Param1, arg2, arg3, Param4)

def srefine(Param1, arg2, arg3, Param4):
    return _irit.srefine(Param1, arg2, arg3, Param4)

def crefine(Param1, INPUT, Param3):
    return _irit.crefine(Param1, INPUT, Param3)

def mraise(Param1, arg2, arg3):
    return _irit.mraise(Param1, arg2, arg3)

def traise(Param1, arg2, arg3):
    return _irit.traise(Param1, arg2, arg3)

def sraise(Param1, arg2, arg3):
    return _irit.sraise(Param1, arg2, arg3)

def craise(Param1, INPUT):
    return _irit.craise(Param1, INPUT)

def creduce(Param1, INPUT):
    return _irit.creduce(Param1, INPUT)

def csurface(Param1, arg2, arg3):
    return _irit.csurface(Param1, arg2, arg3)

def cmesh(Param1, arg2, arg3):
    return _irit.cmesh(Param1, arg2, arg3)

def nth(Param1, INPUT):
    return _irit.nth(Param1, INPUT)

def nref(Param1, INPUT):
    return _irit.nref(Param1, INPUT)

def gpolygon(Param1, INPUT):
    return _irit.gpolygon(Param1, INPUT)

def gpolyline(Param1, INPUT):
    return _irit.gpolyline(Param1, INPUT)

def gpointlist(Param1, arg2, arg3):
    return _irit.gpointlist(Param1, arg2, arg3)

def circle(Param1, INPUT):
    return _irit.circle(Param1, INPUT)

def pcircle(Param1, INPUT):
    return _irit.pcircle(Param1, INPUT)

def pcircapx(Param1, arg2, arg3, arg4, arg5):
    return _irit.pcircapx(Param1, arg2, arg3, arg4, arg5)

def cspiral(arg1, arg2, arg3, arg4):
    return _irit.cspiral(arg1, arg2, arg3, arg4)

def chelix(arg1, arg2, arg3, arg4, arg5):
    return _irit.chelix(arg1, arg2, arg3, arg4, arg5)

def csine(arg1, arg2, arg3):
    return _irit.csine(arg1, arg2, arg3)

def arc(Param1, Param2, Param3):
    return _irit.arc(Param1, Param2, Param3)

def arc360(Param1, arg2, arg3, arg4):
    return _irit.arc360(Param1, arg2, arg3, arg4)

def ruledsrf(Param1, Param2):
    return _irit.ruledsrf(Param1, Param2)

def ruledtv(Param1, Param2):
    return _irit.ruledtv(Param1, Param2)

def ruledvmdl(Param1, Param2, INPUT):
    return _irit.ruledvmdl(Param1, Param2, INPUT)

def boolsum(Param1, Param2, Param3, Param4):
    return _irit.boolsum(Param1, Param2, Param3, Param4)

def boolone(Param1):
    return _irit.boolone(Param1)

def tboolsum(Param1, Param2, Param3, Param4, Param5, Param6):
    return _irit.tboolsum(Param1, Param2, Param3, Param4, Param5, Param6)

def tboolone(Param1):
    return _irit.tboolone(Param1)

def sfromcrvs(Param1, arg2, arg3):
    return _irit.sfromcrvs(Param1, arg2, arg3)

def sintpcrvs(Param1, arg2, arg3, arg4):
    return _irit.sintpcrvs(Param1, arg2, arg3, arg4)

def sweepsrf(Param1, Param2, Param3):
    return _irit.sweepsrf(Param1, Param2, Param3)

def swpsclsrf(Param1, Param2, Param3, Param4, arg5, arg6):
    return _irit.swpsclsrf(Param1, Param2, Param3, Param4, arg5, arg6)

def offset(Param1, Param2, arg3, arg4):
    return _irit.offset(Param1, Param2, arg3, arg4)

def aoffset(Param1, Param2, arg3, arg4, arg5):
    return _irit.aoffset(Param1, Param2, arg3, arg4, arg5)

def coffset(Param1, arg2, arg3, arg4):
    return _irit.coffset(Param1, arg2, arg3, arg4)

def iloffset(Param1, Param2):
    return _irit.iloffset(Param1, Param2)

def loffset(Param1, arg2, arg3, arg4, arg5):
    return _irit.loffset(Param1, arg2, arg3, arg4, arg5)

def moffset(Param1, arg2, arg3):
    return _irit.moffset(Param1, arg2, arg3)

def toffset(Param1, Param2, Param3):
    return _irit.toffset(Param1, Param2, Param3)

def sshell(Param1, Param2):
    return _irit.sshell(Param1, Param2)

def coerce(Param1, INPUT):
    return _irit.coerce(Param1, INPUT)

def ceditpt(Param1, Param2, INPUT):
    return _irit.ceditpt(Param1, Param2, INPUT)

def seditpt(Param1, Param2, arg3, arg4):
    return _irit.seditpt(Param1, Param2, arg3, arg4)

def teditpt(Param1, Param2, arg3, arg4, arg5):
    return _irit.teditpt(Param1, Param2, arg3, arg4, arg5)

def mergepoly(Param1):
    return _irit.mergepoly(Param1)

def mergeplln(Param1, INPUT):
    return _irit.mergeplln(Param1, INPUT)

def mergelist(Param1):
    return _irit.mergelist(Param1)

def cmorph(Param1, Param2, arg3, arg4):
    return _irit.cmorph(Param1, Param2, arg3, arg4)

def pmorph(Param1, Param2, INPUT):
    return _irit.pmorph(Param1, Param2, INPUT)

def smorph(Param1, Param2, INPUT):
    return _irit.smorph(Param1, Param2, INPUT)

def tmorph(Param1, Param2, INPUT):
    return _irit.tmorph(Param1, Param2, INPUT)

def bzr2bsp(Param1):
    return _irit.bzr2bsp(Param1)

def bsp2bzr(Param1):
    return _irit.bsp2bzr(Param1)

def mergetype(Param1, arg2, arg3, arg4):
    return _irit.mergetype(Param1, arg2, arg3, arg4)

def smerge(Param1, Param2, arg3, arg4):
    return _irit.smerge(Param1, Param2, arg3, arg4)

def mmerge(Param1, Param2, arg3, arg4):
    return _irit.mmerge(Param1, Param2, arg3, arg4)

def cderive(Param1):
    return _irit.cderive(Param1)

def sderive(Param1, INPUT):
    return _irit.sderive(Param1, INPUT)

def tderive(Param1, INPUT):
    return _irit.tderive(Param1, INPUT)

def mderive(Param1, INPUT):
    return _irit.mderive(Param1, INPUT)

def tsderive(Param1, INPUT):
    return _irit.tsderive(Param1, INPUT)

def cinteg(Param1):
    return _irit.cinteg(Param1)

def sinteg(Param1, INPUT):
    return _irit.sinteg(Param1, INPUT)

def snrmlsrf(Param1):
    return _irit.snrmlsrf(Param1)

def cnrmlcrv(Param1):
    return _irit.cnrmlcrv(Param1)

def symbprod(Param1, Param2):
    return _irit.symbprod(Param1, Param2)

def symbdprod(Param1, Param2):
    return _irit.symbdprod(Param1, Param2)

def symbcprod(Param1, Param2):
    return _irit.symbcprod(Param1, Param2)

def symbiprod(Param1, arg2, arg3):
    return _irit.symbiprod(Param1, arg2, arg3)

def symbsum(Param1, Param2):
    return _irit.symbsum(Param1, Param2)

def symbdiff(Param1, Param2):
    return _irit.symbdiff(Param1, Param2)

def homomat(Param1):
    return _irit.homomat(Param1)

def projmat(Param1, Param2, INPUT):
    return _irit.projmat(Param1, Param2, INPUT)

def rflctmat(Param1):
    return _irit.rflctmat(Param1)

def matposdir(Param1, Param2, Param3):
    return _irit.matposdir(Param1, Param2, Param3)

def matdecomp(Param1):
    return _irit.matdecomp(Param1)

def matdecomp2(Param1):
    return _irit.matdecomp2(Param1)

def matrecomp(Param1):
    return _irit.matrecomp(Param1)

def cinflect(Param1, arg2, arg3):
    return _irit.cinflect(Param1, arg2, arg3)

def ccrvtr(Param1, arg2, arg3):
    return _irit.ccrvtr(Param1, arg2, arg3)

def cfncrvtr(Param1, arg2, arg3, arg4):
    return _irit.cfncrvtr(Param1, arg2, arg3, arg4)

def scrvtr(Param1, arg2, arg3):
    return _irit.scrvtr(Param1, arg2, arg3)

def sradcrvtr(Param1, Param2, arg3, arg4, arg5):
    return _irit.sradcrvtr(Param1, Param2, arg3, arg4, arg5)

def ciextreme(Param1, arg2, arg3, arg4):
    return _irit.ciextreme(Param1, arg2, arg3, arg4)

def pcrvtr(Param1, arg2, arg3):
    return _irit.pcrvtr(Param1, arg2, arg3)

def pimprtnc(Param1, INPUT):
    return _irit.pimprtnc(Param1, INPUT)

def sgauss(Param1, INPUT):
    return _irit.sgauss(Param1, INPUT)

def smean(Param1, INPUT):
    return _irit.smean(Param1, INPUT)

def sumbilic(Param1, arg2, arg3):
    return _irit.sumbilic(Param1, arg2, arg3)

def sfxcrvtrln(Param1, arg2, arg3, arg4, arg5, arg6):
    return _irit.sfxcrvtrln(Param1, arg2, arg3, arg4, arg5, arg6)

def creparam(Param1, arg2, arg3):
    return _irit.creparam(Param1, arg2, arg3)

def sreparam(Param1, arg2, arg3, arg4):
    return _irit.sreparam(Param1, arg2, arg3, arg4)

def treparam(Param1, arg2, arg3, arg4):
    return _irit.treparam(Param1, arg2, arg3, arg4)

def mreparam(Param1, arg2, arg3, arg4):
    return _irit.mreparam(Param1, arg2, arg3, arg4)

def areparam(Param1, arg2, arg3):
    return _irit.areparam(Param1, arg2, arg3)

def evolute(Param1):
    return _irit.evolute(Param1)

def czeros(Param1, arg2, arg3):
    return _irit.czeros(Param1, arg2, arg3)

def cextremes(Param1, arg2, arg3):
    return _irit.cextremes(Param1, arg2, arg3)

def ppinter(Param1, Param2):
    return _irit.ppinter(Param1, Param2)

def pselfinter(Param1):
    return _irit.pselfinter(Param1)

def ccinter(Param1, Param2, arg3, arg4):
    return _irit.ccinter(Param1, Param2, arg3, arg4)

def ccintrprop(Param1, Param2, INPUT):
    return _irit.ccintrprop(Param1, Param2, INPUT)

def carrangmnt(Param1, arg2, arg3, Param4):
    return _irit.carrangmnt(Param1, arg2, arg3, Param4)

def carngmnt2(Param1, INPUT, Param3):
    return _irit.carngmnt2(Param1, INPUT, Param3)

def beltcurve(Param1, arg2, arg3, arg4):
    return _irit.beltcurve(Param1, arg2, arg3, arg4)

def ssinter(Param1, Param2, arg3, arg4, arg5):
    return _irit.ssinter(Param1, Param2, arg3, arg4, arg5)

def ssintr2(Param1, Param2, arg3, arg4, arg5, arg6, arg7):
    return _irit.ssintr2(Param1, Param2, arg3, arg4, arg5, arg6, arg7)

def scinter(Param1, Param2, arg3, arg4, arg5):
    return _irit.scinter(Param1, Param2, arg3, arg4, arg5)

def slinter(Param1, Param2, Param3, arg4, arg5, arg6):
    return _irit.slinter(Param1, Param2, Param3, arg4, arg5, arg6)

def ssmnkski(Param1, Param2, arg3, arg4, arg5, arg6, arg7):
    return _irit.ssmnkski(Param1, Param2, arg3, arg4, arg5, arg6, arg7)

def csmnkski(Param1, Param2, arg3, arg4, arg5, arg6):
    return _irit.csmnkski(Param1, Param2, arg3, arg4, arg5, arg6)

def mvinter(Param1, arg2, arg3, arg4):
    return _irit.mvinter(Param1, arg2, arg3, arg4)

def mvcontact(Param1, Param2, Param3, arg4, arg5, arg6):
    return _irit.mvcontact(Param1, Param2, Param3, arg4, arg5, arg6)

def nil():
    return _irit.nil()

def coord(Param1, INPUT):
    return _irit.coord(Param1, INPUT)

def Wrapcompose(Param1, Param2, Param3):
    return _irit.Wrapcompose(Param1, Param2, Param3)

def decompose(Param1):
    return _irit.decompose(Param1)

def prisa(Param1, arg2, arg3, arg4, Param5, arg6):
    return _irit.prisa(Param1, arg2, arg3, arg4, Param5, arg6)

def crvptdst(Param1, Param2, arg3, arg4, arg5):
    return _irit.crvptdst(Param1, Param2, arg3, arg4, arg5)

def crvlndst(Param1, Param2, Param3, arg4, arg5):
    return _irit.crvlndst(Param1, Param2, Param3, arg4, arg5)

def srfptdst(Param1, Param2, arg3, arg4, arg5, arg6):
    return _irit.srfptdst(Param1, Param2, arg3, arg4, arg5, arg6)

def srflndst(Param1, Param2, Param3, arg4, arg5, arg6):
    return _irit.srflndst(Param1, Param2, Param3, arg4, arg5, arg6)

def sadapiso(Param1, arg2, arg3, arg4, arg5, arg6, Param7):
    return _irit.sadapiso(Param1, arg2, arg3, arg4, arg5, arg6, Param7)

def tadapiso(Param1, arg2, arg3, arg4, arg5):
    return _irit.tadapiso(Param1, arg2, arg3, arg4, arg5)

def pdomain(Param1):
    return _irit.pdomain(Param1)

def linterp(Param1):
    return _irit.linterp(Param1)

def pinterp(Param1):
    return _irit.pinterp(Param1)

def cinterp(Param1, arg2, arg3, Param4, arg5, arg6):
    return _irit.cinterp(Param1, arg2, arg3, Param4, arg5, arg6)

def cinterp2(Param1, INPUT):
    return _irit.cinterp2(Param1, INPUT)

def sinterp(Param1, Param2):
    return _irit.sinterp(Param1, Param2)

def cmultires(Param1, arg2, arg3):
    return _irit.cmultires(Param1, arg2, arg3)

def getline(INPUT):
    return _irit.getline(INPUT)

def ffextrema(Param1, INPUT):
    return _irit.ffextrema(Param1, INPUT)

def ffextreme(Param1, INPUT):
    return _irit.ffextreme(Param1, INPUT)

def trimsrf(Param1, Param2, INPUT):
    return _irit.trimsrf(Param1, Param2, INPUT)

def trmsrfs(Param1, Param2):
    return _irit.trmsrfs(Param1, Param2)

def strimsrf(Param1):
    return _irit.strimsrf(Param1)

def ctrimsrf(Param1, INPUT):
    return _irit.ctrimsrf(Param1, INPUT)

def tbezier(Param1):
    return _irit.tbezier(Param1)

def tbspline(arg1, arg2, arg3, Param4, Param5):
    return _irit.tbspline(arg1, arg2, arg3, Param4, Param5)

def tsbezier(INPUT, Param2):
    return _irit.tsbezier(INPUT, Param2)

def tsbspline(arg1, arg2, Param3, Param4):
    return _irit.tsbspline(arg1, arg2, Param3, Param4)

def tsgregory(INPUT, Param2):
    return _irit.tsgregory(INPUT, Param2)

def teval(Param1, arg2, arg3, arg4):
    return _irit.teval(Param1, arg2, arg3, arg4)

def tseval(Param1, arg2, arg3, arg4):
    return _irit.tseval(Param1, arg2, arg3, arg4)

def textgeom(Param1, Param2, INPUT):
    return _irit.textgeom(Param1, Param2, INPUT)

def strivar(Param1, arg2, arg3):
    return _irit.strivar(Param1, arg2, arg3)

def smesh(Param1, arg2, arg3):
    return _irit.smesh(Param1, arg2, arg3)

def tinterp(Param1, arg2, arg3, arg4, arg5, arg6, arg7):
    return _irit.tinterp(Param1, arg2, arg3, arg4, arg5, arg6, arg7)

def clntread(arg1, arg2):
    return _irit.clntread(arg1, arg2)

def clntcrsr(INPUT):
    return _irit.clntcrsr(INPUT)

def moment(Param1, INPUT):
    return _irit.moment(Param1, INPUT)

def treverse(Param1, arg2, arg3):
    return _irit.treverse(Param1, arg2, arg3)

def tfromsrfs(Param1, arg2, arg3):
    return _irit.tfromsrfs(Param1, arg2, arg3)

def tintpsrfs(Param1, arg2, arg3, arg4):
    return _irit.tintpsrfs(Param1, arg2, arg3, arg4)

def tvrev(Param1):
    return _irit.tvrev(Param1)

def tvprev(Param1):
    return _irit.tvprev(Param1)

def tvrev2(Param1, arg2, arg3):
    return _irit.tvrev2(Param1, arg2, arg3)

def tvprev2(Param1, arg2, arg3):
    return _irit.tvprev2(Param1, arg2, arg3)

def vmdlrev(Param1, Param2, Param3, arg4, arg5, arg6):
    return _irit.vmdlrev(Param1, Param2, Param3, arg4, arg5, arg6)

def vmdlswp(Param1, Param2, Param3, Param4, INPUT):
    return _irit.vmdlswp(Param1, Param2, Param3, Param4, INPUT)

def sfocal(Param1, INPUT):
    return _irit.sfocal(Param1, INPUT)

def hermite(Param1, Param2, Param3, Param4):
    return _irit.hermite(Param1, Param2, Param3, Param4)

def blnd2srfs(Param1, Param2, arg3, arg4):
    return _irit.blnd2srfs(Param1, Param2, arg3, arg4)

def blhermite(Param1, Param2, Param3, Param4, Param5, Param6):
    return _irit.blhermite(Param1, Param2, Param3, Param4, Param5, Param6)

def blshermite(Param1, Param2, Param3, INPUT, Param5, Param6):
    return _irit.blshermite(Param1, Param2, Param3, INPUT, Param5, Param6)

def ffmatch(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8):
    return _irit.ffmatch(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8)

def Wrapcontour(Param1, Param2, Param3, Param4, Param5):
    return _irit.Wrapcontour(Param1, Param2, Param3, Param4, Param5)

def printer(Param1, Param2, INPUT):
    return _irit.printer(Param1, Param2, INPUT)

def srinter(Param1, Param2, Param3, arg4, arg5):
    return _irit.srinter(Param1, Param2, Param3, arg4, arg5)

def ppinclude(Param1, Param2):
    return _irit.ppinclude(Param1, Param2)

def cpinclude(Param1, Param2, INPUT):
    return _irit.cpinclude(Param1, Param2, INPUT)

def tpinclude(Param1, Param2, INPUT):
    return _irit.tpinclude(Param1, Param2, INPUT)

def pln3pts(Param1, Param2, Param3):
    return _irit.pln3pts(Param1, Param2, Param3)

def ptptln(Param1, Param2, Param3):
    return _irit.ptptln(Param1, Param2, Param3)

def ptlnpln(Param1, Param2, Param3):
    return _irit.ptlnpln(Param1, Param2, Param3)

def ptslnln(Param1, Param2, Param3, Param4):
    return _irit.ptslnln(Param1, Param2, Param3, Param4)

def ptscrcr(Param1, Param2, arg3, Param4, Param5, arg6):
    return _irit.ptscrcr(Param1, Param2, arg3, Param4, Param5, arg6)

def tnscrcr(Param1, arg2, Param3, arg4, arg5):
    return _irit.tnscrcr(Param1, arg2, Param3, arg4, arg5)

def pt3bary(Param1, Param2, Param3, Param4):
    return _irit.pt3bary(Param1, Param2, Param3, Param4)

def ffsplit(Param1):
    return _irit.ffsplit(Param1)

def ffmerge(Param1, INPUT):
    return _irit.ffmerge(Param1, INPUT)

def ffpttype(Param1):
    return _irit.ffpttype(Param1)

def ffgtype(Param1):
    return _irit.ffgtype(Param1)

def fforder(Param1):
    return _irit.fforder(Param1)

def ffmsize(Param1):
    return _irit.ffmsize(Param1)

def ffmesh(Param1):
    return _irit.ffmesh(Param1)

def ffkntlns(Param1, INPUT):
    return _irit.ffkntlns(Param1, INPUT)

def ffkntvec(Param1):
    return _irit.ffkntvec(Param1)

def ffctlpts(Param1):
    return _irit.ffctlpts(Param1)

def ffpoles(Param1):
    return _irit.ffpoles(Param1)

def ffspltpoles(Param1, arg2, arg3, arg4):
    return _irit.ffspltpoles(Param1, arg2, arg3, arg4)

def cnvxhull(Param1, INPUT):
    return _irit.cnvxhull(Param1, INPUT)

def mscone(Param1):
    return _irit.mscone(Param1)

def mscirc(Param1, Param2):
    return _irit.mscirc(Param1, Param2)

def mssphere(Param1):
    return _irit.mssphere(Param1)

def crvpttan(Param1, Param2, INPUT):
    return _irit.crvpttan(Param1, Param2, INPUT)

def crv2tans(Param1, INPUT):
    return _irit.crv2tans(Param1, INPUT)

def crc2crvtan(Param1, Param2, arg3, arg4):
    return _irit.crc2crvtan(Param1, Param2, arg3, arg4)

def crvc1rnd(Param1, arg2, arg3):
    return _irit.crvc1rnd(Param1, arg2, arg3)

def srf3tans(Param1, arg2, arg3, arg4):
    return _irit.srf3tans(Param1, arg2, arg3, arg4)

def srf3tansln(Param1, arg2, arg3, arg4, arg5):
    return _irit.srf3tansln(Param1, arg2, arg3, arg4, arg5)

def instance(Param1, Param2):
    return _irit.instance(Param1, Param2)

def canglemap(Param1, arg2, arg3, arg4):
    return _irit.canglemap(Param1, arg2, arg3, arg4)

def cviewmap(Param1, Param2, arg3, arg4, arg5):
    return _irit.cviewmap(Param1, Param2, arg3, arg4, arg5)

def cvisible(Param1, Param2, INPUT):
    return _irit.cvisible(Param1, Param2, INPUT)

def svisible(Param1, arg2, arg3):
    return _irit.svisible(Param1, arg2, arg3)

def getattr(Param1, Param2):
    return _irit.getattr(Param1, Param2)

def pthmspr(INPUT):
    return _irit.pthmspr(INPUT)

def pdecimate(Param1, arg2, arg3):
    return _irit.pdecimate(Param1, arg2, arg3)

def ffptdist(Param1, arg2, arg3):
    return _irit.ffptdist(Param1, arg2, arg3)

def cenvoff(Param1, arg2, arg3):
    return _irit.cenvoff(Param1, arg2, arg3)

def cbisector2d(Param1, arg2, arg3, arg4, arg5, arg6):
    return _irit.cbisector2d(Param1, arg2, arg3, arg4, arg5, arg6)

def cbisector3d(Param1, INPUT):
    return _irit.cbisector3d(Param1, INPUT)

def calphasector(Param1, INPUT):
    return _irit.calphasector(Param1, INPUT)

def sbisector(Param1, Param2):
    return _irit.sbisector(Param1, Param2)

def mbisector(Param1, Param2, arg3, arg4, arg5):
    return _irit.mbisector(Param1, Param2, arg3, arg4, arg5)

def mtrisector(Param1, Param2, Param3, arg4, arg5, arg6, Param7, Param8):
    return _irit.mtrisector(Param1, Param2, Param3, arg4, arg5, arg6, Param7, Param8)

def cvoronoicell(Param1):
    return _irit.cvoronoicell(Param1)

def cmat2d(Param1, arg2, arg3):
    return _irit.cmat2d(Param1, arg2, arg3)

def sprbisect(Param1, INPUT):
    return _irit.sprbisect(Param1, INPUT)

def bsctplnpt(Param1, INPUT):
    return _irit.bsctplnpt(Param1, INPUT)

def bsctcylpt(Param1, Param2, arg3, Param4, arg5):
    return _irit.bsctcylpt(Param1, Param2, arg3, Param4, arg5)

def bsctconpt(Param1, Param2, arg3, Param4, arg5):
    return _irit.bsctconpt(Param1, Param2, arg3, Param4, arg5)

def bsctsprpt(Param1, INPUT, Param3):
    return _irit.bsctsprpt(Param1, INPUT, Param3)

def bscttrspt(Param1, Param2, arg3, arg4, Param5):
    return _irit.bscttrspt(Param1, Param2, arg3, arg4, Param5)

def bsctplnln(Param1, INPUT):
    return _irit.bsctplnln(Param1, INPUT)

def bsctconln(Param1, arg2, Param3, arg4):
    return _irit.bsctconln(Param1, arg2, Param3, arg4)

def bsctsprln(Param1, arg2, arg3):
    return _irit.bsctsprln(Param1, arg2, arg3)

def bsctsprpl(Param1, arg2, arg3):
    return _irit.bsctsprpl(Param1, arg2, arg3)

def bsctcylpl(Param1, Param2, arg3, arg4):
    return _irit.bsctcylpl(Param1, Param2, arg3, arg4)

def bsctconpl(Param1, Param2, arg3, arg4):
    return _irit.bsctconpl(Param1, Param2, arg3, arg4)

def bsctconcon(Param1, arg2, Param3, arg4, arg5):
    return _irit.bsctconcon(Param1, arg2, Param3, arg4, arg5)

def bsctconcn2(Param1, Param2, arg3, Param4, Param5, arg6):
    return _irit.bsctconcn2(Param1, Param2, arg3, Param4, Param5, arg6)

def bsctconspr(Param1, Param2, arg3, Param4, arg5, arg6):
    return _irit.bsctconspr(Param1, Param2, arg3, Param4, arg5, arg6)

def bsctcylspr(Param1, Param2, arg3, Param4, arg5, arg6):
    return _irit.bsctcylspr(Param1, Param2, arg3, Param4, arg5, arg6)

def bsctsprspr(Param1, arg2, Param3, arg4):
    return _irit.bsctsprspr(Param1, arg2, Param3, arg4)

def bscttrsspr(Param1, Param2, arg3, arg4, Param5, arg6):
    return _irit.bscttrsspr(Param1, Param2, arg3, arg4, Param5, arg6)

def bscttrstrs(Param1, Param2, arg3, Param4, Param5, arg6, arg7):
    return _irit.bscttrstrs(Param1, Param2, arg3, Param4, Param5, arg6, arg7)

def bsctcylcyl(Param1, Param2, arg3, Param4, Param5, arg6):
    return _irit.bsctcylcyl(Param1, Param2, arg3, Param4, Param5, arg6)

def bsctconcyl(Param1, Param2, arg3, Param4, Param5, arg6):
    return _irit.bsctconcyl(Param1, Param2, arg3, Param4, Param5, arg6)

def skel2dint(Param1, Param2, Param3, arg4, arg5, arg6, Param7):
    return _irit.skel2dint(Param1, Param2, Param3, arg4, arg5, arg6, Param7)

def skelndint(Param1, arg2, arg3, arg4):
    return _irit.skelndint(Param1, arg2, arg3, arg4)

def bbox(Param1):
    return _irit.bbox(Param1)

def orthotomc(Param1, Param2, INPUT):
    return _irit.orthotomc(Param1, Param2, INPUT)

def boundary(Param1):
    return _irit.boundary(Param1)

def silhouette(Param1, Param2, arg3, arg4):
    return _irit.silhouette(Param1, Param2, arg3, arg4)

def saspctgrph(Param1, INPUT):
    return _irit.saspctgrph(Param1, INPUT)

def ssilinfl(Param1, Param2, arg3, arg4):
    return _irit.ssilinfl(Param1, Param2, arg3, arg4)

def polarsil(Param1, Param2, arg3, arg4):
    return _irit.polarsil(Param1, Param2, arg3, arg4)

def isocline(Param1, Param2, arg3, arg4, arg5, arg6):
    return _irit.isocline(Param1, Param2, arg3, arg4, arg5, arg6)

def tcrvtr(Param1, Param2, INPUT):
    return _irit.tcrvtr(Param1, Param2, INPUT)

def mrchcube(Param1, Param2, arg3, arg4):
    return _irit.mrchcube(Param1, Param2, arg3, arg4)

def triangl(Param1, INPUT):
    return _irit.triangl(Param1, INPUT)

def maxedgelen(Param1, INPUT):
    return _irit.maxedgelen(Param1, INPUT)

def pts2plln(Param1, INPUT):
    return _irit.pts2plln(Param1, INPUT)

def coverpt(Param1, INPUT, Param3):
    return _irit.coverpt(Param1, INPUT, Param3)

def coveriso(Param1, arg2, arg3, Param4, arg5, arg6, Param7):
    return _irit.coveriso(Param1, arg2, arg3, Param4, arg5, arg6, Param7)

def tvload(Param1, INPUT, Param3, Param4):
    return _irit.tvload(Param1, INPUT, Param3, Param4)

def duality(Param1):
    return _irit.duality(Param1)

def sdvlpcrv(Param1, Param2, Param3):
    return _irit.sdvlpcrv(Param1, Param2, Param3)

def algsum(Param1, Param2):
    return _irit.algsum(Param1, Param2)

def algprod(Param1, Param2):
    return _irit.algprod(Param1, Param2)

def swungasum(Param1, Param2):
    return _irit.swungasum(Param1, Param2)

def mpromote(Param1, Param2):
    return _irit.mpromote(Param1, Param2)

def mreverse(Param1, arg2, arg3):
    return _irit.mreverse(Param1, arg2, arg3)

def mfrommv(Param1, arg2, arg3):
    return _irit.mfrommv(Param1, arg2, arg3)

def mfrommesh(Param1, arg2, arg3):
    return _irit.mfrommesh(Param1, arg2, arg3)

def meval(Param1, Param2):
    return _irit.meval(Param1, Param2)

def mzero(Param1, Param2, arg3, arg4):
    return _irit.mzero(Param1, Param2, arg3, arg4)

def munivzero(Param1, arg2, arg3, arg4):
    return _irit.munivzero(Param1, arg2, arg3, arg4)

def sparabolc(Param1, arg2, arg3, arg4, arg5):
    return _irit.sparabolc(Param1, arg2, arg3, arg4, arg5)

def rrinter(Param1, Param2, Param3, Param4, arg5, arg6):
    return _irit.rrinter(Param1, Param2, Param3, Param4, arg5, arg6)

def gginter(Param1, Param2, Param3, Param4, arg5, arg6):
    return _irit.gginter(Param1, Param2, Param3, Param4, arg5, arg6)

def sreverse(Param1):
    return _irit.sreverse(Param1)

def conicsec(Param1, arg2, arg3, arg4):
    return _irit.conicsec(Param1, arg2, arg3, arg4)

def ellipse3pt(Param1, Param2, Param3, INPUT):
    return _irit.ellipse3pt(Param1, Param2, Param3, INPUT)

def quadric(Param1):
    return _irit.quadric(Param1)

def cnc2quad(Param1, INPUT):
    return _irit.cnc2quad(Param1, INPUT)

def implctrans(INPUT, Param2, Param3):
    return _irit.implctrans(INPUT, Param2, Param3)

def iritstate(Param1, Param2):
    return _irit.iritstate(Param1, Param2)

def isgeom(Param1, arg2, arg3):
    return _irit.isgeom(Param1, arg2, arg3)

def smoothnrml(Param1, INPUT):
    return _irit.smoothnrml(Param1, INPUT)

def fixplnrml(Param1, INPUT):
    return _irit.fixplnrml(Param1, INPUT)

def fixplgeom(Param1, arg2, arg3):
    return _irit.fixplgeom(Param1, arg2, arg3)

def blossom(Param1, Param2):
    return _irit.blossom(Param1, Param2)

def knotclean(Param1):
    return _irit.knotclean(Param1)

def knotremove(Param1, INPUT):
    return _irit.knotremove(Param1, INPUT)

def pktri3crcs(Param1, Param2, Param3, arg4, arg5, arg6):
    return _irit.pktri3crcs(Param1, Param2, Param3, arg4, arg5, arg6)

def pktri6crcs(Param1, Param2, Param3, arg4, arg5, arg6):
    return _irit.pktri6crcs(Param1, Param2, Param3, arg4, arg5, arg6)

def raytraps(Param1, arg2, arg3, arg4, arg5):
    return _irit.raytraps(Param1, arg2, arg3, arg4, arg5)

def ctrlcycle(Param1, arg2, arg3, arg4):
    return _irit.ctrlcycle(Param1, arg2, arg3, arg4)

def cmoebius(Param1, INPUT):
    return _irit.cmoebius(Param1, INPUT)

def smoebius(Param1, arg2, arg3):
    return _irit.smoebius(Param1, arg2, arg3)

def rflctln(Param1, Param2, Param3, INPUT):
    return _irit.rflctln(Param1, Param2, Param3, INPUT)

def carea(Param1):
    return _irit.carea(Param1)

def svolume(Param1, arg2, arg3):
    return _irit.svolume(Param1, arg2, arg3)

def smoments(Param1, arg2, arg3, arg4, arg5):
    return _irit.smoments(Param1, arg2, arg3, arg4, arg5)

def simpjacob(Param1, arg2, arg3):
    return _irit.simpjacob(Param1, arg2, arg3)

def tvzrjacob(Param1, arg2, arg3, Param4):
    return _irit.tvzrjacob(Param1, arg2, arg3, Param4)

def tvjacobian(Param1):
    return _irit.tvjacobian(Param1)

def tvimpjacob(Param1, arg2, arg3):
    return _irit.tvimpjacob(Param1, arg2, arg3)

def crvkernel(Param1, arg2, arg3, Param4, arg5):
    return _irit.crvkernel(Param1, arg2, arg3, Param4, arg5)

def srfkernel(Param1, arg2, arg3):
    return _irit.srfkernel(Param1, arg2, arg3)

def crvdiamtr(Param1, arg2, arg3, arg4):
    return _irit.crvdiamtr(Param1, arg2, arg3, arg4)

def saccess(Param1, Param2, Param3, arg4, arg5):
    return _irit.saccess(Param1, Param2, Param3, arg4, arg5)

def sflecnodal(Param1, arg2, arg3, arg4):
    return _irit.sflecnodal(Param1, arg2, arg3, arg4)

def srf2tans(Param1, Param2, arg3, arg4):
    return _irit.srf2tans(Param1, Param2, arg3, arg4)

def nrmlcone(Param1):
    return _irit.nrmlcone(Param1)

def ptregister(Param1, Param2, arg3, arg4):
    return _irit.ptregister(Param1, Param2, arg3, arg4)

def getname(Param1, INPUT):
    return _irit.getname(Param1, INPUT)

def sddmmap(Param1, Param2, arg3, arg4, arg5):
    return _irit.sddmmap(Param1, Param2, arg3, arg4, arg5)

def mvexplicit(INPUT, Param2):
    return _irit.mvexplicit(INPUT, Param2)

def analyfit(Param1, Param2, arg3, arg4):
    return _irit.analyfit(Param1, Param2, arg3, arg4)

def planeclip(Param1, Param2):
    return _irit.planeclip(Param1, Param2)

def srffform(Param1, INPUT):
    return _irit.srffform(Param1, INPUT)

def ccrvtreval(Param1, INPUT):
    return _irit.ccrvtreval(Param1, INPUT)

def scrvtreval(Param1, arg2, arg3, arg4):
    return _irit.scrvtreval(Param1, arg2, arg3, arg4)

def sasympeval(Param1, arg2, arg3, arg4):
    return _irit.sasympeval(Param1, arg2, arg3, arg4)

def carclen(Param1, arg2, arg3):
    return _irit.carclen(Param1, arg2, arg3)

def textwarp(Param1, Param2, arg3, arg4, arg5, arg6):
    return _irit.textwarp(Param1, Param2, arg3, arg4, arg5, arg6)

def srayclip(Param1, Param2, Param3):
    return _irit.srayclip(Param1, Param2, Param3)

def ppropftch(Param1, INPUT, Param3):
    return _irit.ppropftch(Param1, INPUT, Param3)

def fitpmodel(Param1, arg2, arg3, arg4):
    return _irit.fitpmodel(Param1, arg2, arg3, arg4)

def uvpoly(Param1, Param2, Param3):
    return _irit.uvpoly(Param1, Param2, Param3)

def mpower(Param1, Param2):
    return _irit.mpower(Param1, Param2)

def mbezier(Param1, Param2):
    return _irit.mbezier(Param1, Param2)

def mbspline(Param1, Param2, Param3, Param4):
    return _irit.mbspline(Param1, Param2, Param3, Param4)

def cbiarcs(Param1, arg2, arg3):
    return _irit.cbiarcs(Param1, arg2, arg3)

def ccubics(Param1, INPUT):
    return _irit.ccubics(Param1, INPUT)

def splitlst(Param1):
    return _irit.splitlst(Param1)

def setcover(Param1, INPUT):
    return _irit.setcover(Param1, INPUT)

def dist2ff(Param1, Param2, INPUT):
    return _irit.dist2ff(Param1, Param2, INPUT)

def ffrigidsim(Param1, Param2, INPUT):
    return _irit.ffrigidsim(Param1, Param2, INPUT)

def ffcmpcrvs(Param1, Param2, INPUT):
    return _irit.ffcmpcrvs(Param1, Param2, INPUT)

def animeval(arg1, Param2, arg3):
    return _irit.animeval(arg1, Param2, arg3)

def cubiccrvs(Param1, arg2, arg3):
    return _irit.cubiccrvs(Param1, arg2, arg3)

def quadcrvs(Param1, arg2, arg3):
    return _irit.quadcrvs(Param1, arg2, arg3)

def cbsp_fit(Param1, Param2, INPUT, Param4):
    return _irit.cbsp_fit(Param1, Param2, INPUT, Param4)

def lowbzrfit(Param1, INPUT):
    return _irit.lowbzrfit(Param1, INPUT)

def antipodal(Param1, arg2, arg3):
    return _irit.antipodal(Param1, arg2, arg3)

def selfinter(Param1, arg2, arg3, arg4, arg5):
    return _irit.selfinter(Param1, arg2, arg3, arg4, arg5)

def pts2plys(Param1, INPUT):
    return _irit.pts2plys(Param1, INPUT)

def ccrvtr1pt(Param1, arg2, arg3, arg4, arg5, arg6, arg7):
    return _irit.ccrvtr1pt(Param1, arg2, arg3, arg4, arg5, arg6, arg7)

def mindist2ff(Param1, Param2, INPUT):
    return _irit.mindist2ff(Param1, Param2, INPUT)

def hausdorff(Param1, Param2, arg3, arg4):
    return _irit.hausdorff(Param1, Param2, arg3, arg4)

def nccntrpath(Param1, arg2, arg3, arg4, arg5):
    return _irit.nccntrpath(Param1, arg2, arg3, arg4, arg5)

def ncpcktpath(Param1, arg2, arg3, arg4, arg5, arg6, arg7):
    return _irit.ncpcktpath(Param1, arg2, arg3, arg4, arg5, arg6, arg7)

def uvecsonspr(INPUT):
    return _irit.uvecsonspr(INPUT)

def mfrom2img(Param1, Param2, arg3, Param4, arg5, arg6, arg7, arg8, arg9, arg10, arg11):
    return _irit.mfrom2img(Param1, Param2, arg3, Param4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)

def mfrom3img(Param1, Param2, Param3, arg4, Param5, arg6, arg7, arg8, arg9, arg10, arg11, arg12):
    return _irit.mfrom3img(Param1, Param2, Param3, arg4, Param5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)

def bfrom2img(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8):
    return _irit.bfrom2img(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8)

def bfrom3img(Param1, Param2, Param3, arg4, arg5, arg6, arg7, arg8, arg9):
    return _irit.bfrom3img(Param1, Param2, Param3, arg4, arg5, arg6, arg7, arg8, arg9)

def ruledfit(Param1, arg2, arg3, arg4):
    return _irit.ruledfit(Param1, arg2, arg3, arg4)

def csrfproj(Param1, Param2, arg3, arg4):
    return _irit.csrfproj(Param1, Param2, arg3, arg4)

def ffextend(Param1, Param2, Param3, INPUT):
    return _irit.ffextend(Param1, Param2, Param3, INPUT)

def ffiga(INPUT, Param2):
    return _irit.ffiga(INPUT, Param2)

def text2geom(Param1, Param2, arg3, arg4, arg5, Param6, arg7, arg8):
    return _irit.text2geom(Param1, Param2, arg3, arg4, arg5, Param6, arg7, arg8)

def textlayshp(Param1, Param2, arg3, arg4, Param5, arg6, arg7, Param8, arg9, arg10, Param11):
    return _irit.textlayshp(Param1, Param2, arg3, arg4, Param5, arg6, arg7, Param8, arg9, arg10, Param11)

def psubdiv(Param1, arg2, arg3, arg4, arg5, arg6):
    return _irit.psubdiv(Param1, arg2, arg3, arg4, arg5, arg6)

def pruledalg(Param1, arg2, arg3, arg4, arg5, arg6, arg7):
    return _irit.pruledalg(Param1, arg2, arg3, arg4, arg5, arg6, arg7)

def pdvlpalg(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10):
    return _irit.pdvlpalg(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)

def c2contact(Param1, Param2, arg3, arg4, arg5):
    return _irit.c2contact(Param1, Param2, arg3, arg4, arg5)

def tdeform(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8):
    return _irit.tdeform(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8)

def plyround(INPUT, Param2, Param3, Param4):
    return _irit.plyround(INPUT, Param2, Param3, Param4)

def crvcover(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8):
    return _irit.crvcover(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8)

def bfzeros(Param1, arg2, arg3, arg4, arg5):
    return _irit.bfzeros(Param1, arg2, arg3, arg4, arg5)

def stewartpl(Param1, Param2, Param3, Param4):
    return _irit.stewartpl(Param1, Param2, Param3, Param4)

def circpack(Param1, arg2, arg3, arg4, arg5):
    return _irit.circpack(Param1, arg2, arg3, arg4, arg5)

def dvlpstrip(Param1, Param2, Param3, Param4, Param5, Param6, arg7, arg8, arg9):
    return _irit.dvlpstrip(Param1, Param2, Param3, Param4, Param5, Param6, arg7, arg8, arg9)

def untrim(Param1, Param2, INPUT):
    return _irit.untrim(Param1, Param2, INPUT)

def vmslice(Param1, Param2, INPUT, Param4):
    return _irit.vmslice(Param1, Param2, INPUT, Param4)

def vmblend(Param1, Param2, INPUT, Param4):
    return _irit.vmblend(Param1, Param2, INPUT, Param4)

def toolswep(Param1, Param2, Param3, arg4, Param5, Param6, arg7, arg8, Param9, arg10, arg11, Param12):
    return _irit.toolswep(Param1, Param2, Param3, arg4, Param5, Param6, arg7, arg8, Param9, arg10, arg11, Param12)

def microstrct(Param1, INPUT, Param3):
    return _irit.microstrct(Param1, INPUT, Param3)

def microtile(INPUT, Param2):
    return _irit.microtile(INPUT, Param2)

def microslice(INPUT, Param2, Param3, Param4, Param5, Param6):
    return _irit.microslice(INPUT, Param2, Param3, Param4, Param5, Param6)

def unstrctgrid(INPUT, Param2):
    return _irit.unstrctgrid(INPUT, Param2)

def accessanlz(INPUT, Param2):
    return _irit.accessanlz(INPUT, Param2)

def accss2anlz(arg1, Param2, Param3, arg4, arg5, arg6, Param7):
    return _irit.accss2anlz(arg1, Param2, Param3, arg4, arg5, arg6, Param7)

def srforthonet(Param1, Param2, arg3, arg4):
    return _irit.srforthonet(Param1, Param2, arg3, arg4)

def rocketfuel(Param1, Param2, Param3, Param4, arg5, arg6, arg7):
    return _irit.rocketfuel(Param1, Param2, Param3, Param4, arg5, arg6, arg7)

def eucofstonsrf(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8):
    return _irit.eucofstonsrf(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8)

def eucsprlonsrf(Param1, arg2, arg3, arg4, arg5, arg6, arg7):
    return _irit.eucsprlonsrf(Param1, arg2, arg3, arg4, arg5, arg6, arg7)

def amfiber3axis(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8, arg9):
    return _irit.amfiber3axis(Param1, Param2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)

def art2glry(Param1, Param2):
    return _irit.art2glry(Param1, Param2)

def exit():
    return _irit.exit()

def reset():
    return _irit.reset()

def viewobj(Param1):
    return _irit.viewobj(Param1)

def viewset(INPUT):
    return _irit.viewset(INPUT)

def chdir(Param1):
    return _irit.chdir(Param1)

def include(Param1):
    return _irit.include(Param1)

def save(Param1, Param2):
    return _irit.save(Param1, Param2)

def free(Param1):
    return _irit.free(Param1)

def fnfree(Param1):
    return _irit.fnfree(Param1)

def help(Param1):
    return _irit.help(Param1)

def varlist():
    return _irit.varlist()

def system(Param1):
    return _irit.system(Param1)

def logfile(Param1):
    return _irit.logfile(Param1)

def color(Param1, INPUT):
    return _irit.color(Param1, INPUT)

def awidth(Param1, INPUT):
    return _irit.awidth(Param1, INPUT)

def adwidth(Param1, INPUT):
    return _irit.adwidth(Param1, INPUT)

def snoc(Param1, Param2):
    return _irit.snoc(Param1, Param2)

def attrib(Param1, Param2, Param3):
    return _irit.attrib(Param1, Param2, Param3)

def attrprop(Param1, Param2, Param3):
    return _irit.attrprop(Param1, Param2, Param3)

def attrvprop(Param1, Param2):
    return _irit.attrvprop(Param1, Param2)

def cpattr(Param1, Param2):
    return _irit.cpattr(Param1, Param2)

def rmattr(Param1, Param2):
    return _irit.rmattr(Param1, Param2)

def ffcompat(Param1, Param2):
    return _irit.ffcompat(Param1, Param2)

def msleep(INPUT):
    return _irit.msleep(INPUT)

def printf(Param1, Param2):
    return _irit.printf(Param1, Param2)

def printfile(Param1):
    return _irit.printfile(Param1)

def error(Param1):
    return _irit.error(Param1)

def clntwrite(INPUT, Param2):
    return _irit.clntwrite(INPUT, Param2)

def clntclose(arg1, arg2):
    return _irit.clntclose(arg1, arg2)

def setname(Param1, INPUT, Param3):
    return _irit.setname(Param1, INPUT, Param3)

def insertpoly(Param1, Param2):
    return _irit.insertpoly(Param1, Param2)

def ditherimage(Param1, Param2, arg3, arg4):
    return _irit.ditherimage(Param1, Param2, arg3, arg4)

def gupdateparams(Param1, Param2, Param3):
    return _irit.gupdateparams(Param1, Param2, Param3)

def examplefunc(INPUT, Param2):
    return _irit.examplefunc(INPUT, Param2)

def IritInit():
    return _irit.IritInit()

def CreateCtlPt(type, NumParams, Params):
    return _irit.CreateCtlPt(type, NumParams, Params)

def ObjectFreeByPtr(PObj):
    return _irit.ObjectFreeByPtr(PObj)

def IritQueryFunctions():
    return _irit.IritQueryFunctions()

def GetResolution():
    return _irit.GetResolution()

def SetResolution(Res):
    return _irit.SetResolution(Res)

def GetViewMatrix():
    return _irit.GetViewMatrix()

def SetViewMatrix(arg1):
    return _irit.SetViewMatrix(arg1)

def GetPrspMatrix():
    return _irit.GetPrspMatrix()

def SetPrspMatrix(arg1):
    return _irit.SetPrspMatrix(arg1)

def PrintObject(arg1):
    return _irit.PrintObject(arg1)

def PrintObjectErr(arg1):
    return _irit.PrintObjectErr(arg1)

def String(string):
    return _irit.String(string)

def GenStrObject(string):
    return _irit.GenStrObject(string)

def GenVecObject(x, y, z):
    return _irit.GenVecObject(x, y, z)

def Real(num):
    return _irit.Real(num)

def GenRealObject(num):
    return _irit.GenRealObject(num)

def Int(num):
    return _irit.Int(num)

def GenIntObject(num):
    return _irit.GenIntObject(num)

def GenNullObject():
    return _irit.GenNullObject()

def IsNullObject(PObj):
    return _irit.IsNullObject(PObj)

def ThisObject(arg1):
    return _irit.ThisObject(arg1)

def GetMeshSize(FFObj, Dir):
    return _irit.GetMeshSize(FFObj, Dir)

def tvolume(*args):
    return _irit.tvolume(*args)

def FetchStrObject(obj):
    return _irit.FetchStrObject(obj)

def FetchRealObject(obj):
    return _irit.FetchRealObject(obj)

def FetchIntObject(obj):
    return _irit.FetchIntObject(obj)

def GetAxes():
    return _irit.GetAxes()

def SetObjectName(PObj, Name):
    return _irit.SetObjectName(PObj, Name)

def GetDrawCtlpt():
    return _irit.GetDrawCtlpt()

def SetDrawCtlpt(val):
    return _irit.SetDrawCtlpt(val)

def GetFlat4Ply():
    return _irit.GetFlat4Ply()

def SetFlat4Ply(val):
    return _irit.SetFlat4Ply(val)

def GetPolyApproxOpt():
    return _irit.GetPolyApproxOpt()

def SetPolyApproxOpt(val):
    return _irit.SetPolyApproxOpt(val)

def GetPolyApproxUV():
    return _irit.GetPolyApproxUV()

def SetPolyApproxUV(val):
    return _irit.SetPolyApproxUV(val)

def GetPolyApproxTri():
    return _irit.GetPolyApproxTri()

def SetPolyApproxTri(val):
    return _irit.SetPolyApproxTri(val)

def GetPolyApproxTol():
    return _irit.GetPolyApproxTol()

def SetPolyApproxTol(val):
    return _irit.SetPolyApproxTol(val)

def GetPolyMergeCoplanar():
    return _irit.GetPolyMergeCoplanar()

def IritPySetPolyMergeCoplanar(val):
    return _irit.IritPySetPolyMergeCoplanar(val)

def GetMachine():
    return _irit.GetMachine()

def GetUsrFnList():
    return _irit.GetUsrFnList()

import irit
import math
IritDisplayDeviceActive = 0;
import atexit
def exitDisplayDevice():
    if irit.IritDisplayDeviceActive == 1:
            irit.viewexit()
            irit.msleep(500)

atexit.register(exitDisplayDevice)

irit.IritInit()

def Fetch3TupleObject(vec) :
    return (irit.FetchRealObject(irit.coord(vec,0)),\
            irit.FetchRealObject(irit.coord(vec,1)),\
            irit.FetchRealObject(irit.coord(vec,2)))

def Fetch4TupleObject(vec) :
    return (irit.FetchRealObject(irit.coord(vec,0)),\
            irit.FetchRealObject(irit.coord(vec,1)),\
            irit.FetchRealObject(irit.coord(vec,2)),\
            irit.FetchRealObject(irit.coord(vec,3)) )

def normalizePt(x):
    x0 = irit.FetchRealObject( irit.coord( x, 0 ) )
    x1 = irit.FetchRealObject( irit.coord( x, 1 ) )
    x2 = irit.FetchRealObject( irit.coord( x, 2 ) )
    len = math.sqrt( x0 * x0 + x1 * x1 + x2 * x2 )
    return irit.point( x0/len, x1/len, x2/len )

def normalizeVec(x):
    return irit.coerce( irit.normalizePt(x), irit.VECTOR_TYPE )        

def list(*objs):
    objList = irit.nil()
    for i in range(len(objs)):
        objType = type(objs[i])
        if objType == int or objType == float:
            obj = irit.GenRealObject(objs[i])
        elif objType == str:
            obj = irit.GenStrObject(objs[i])
        elif objType == tuple and len(objs[i]) == 3:
            obj = irit.point(objs[i][0], objs[i][1], objs[i][2])
        else:
            obj = objs[i]
        irit.snoc(obj, objList)
    return objList           

def ctlpt(*objs):
    arr = irit.new_doubleArray(len(objs))
    irit.doubleArray_setitem(arr, 0, 0)
    for i in range(1, len(objs)):
        objType = type(objs[i])
        if objType == int or objType == float:
            irit.doubleArray_setitem(arr, i, objs[i])
        else:
            irit.doubleArray_setitem(arr, i, irit.FetchRealObject(objs[i]))
    return irit.CreateCtlPt(objs[0], len(objs), arr)

def contour(param1, param2, param3 = irit.GenNullObject(), param4 = irit.GenNullObject(), param5 = irit.GenNullObject() ):
    return irit.Wrapcontour(param1, param2, param3, param4, param5)

def compose(param1, param2, param3 = irit.GenNullObject() ):
    return irit.Wrapcompose(param1, param2, param3)

def free(param1):
    irit.ObjectFreeByPtr(param1)

def freeuserdeffuncs( funcnamelist ):
    i = 1
    while ( i <= irit.SizeOf( funcnamelist ) ):
        irit.fnfree( irit.nth( funcnamelist, i ) )
        i = i + 1

def demo(  ):
    irit.include( "demo.irt" )

def pause(  ):
    irit.printf( "press return to continue:", irit.nil(  ) )
    t = irit.getline( 9 )

def milisleep( n ):
    irit.msleep( n )

# 
#  Some simple functions.
# 
def iseven( x ):
    retval = x == math.floor( x/2.0 ) * 2
    return retval

def mod( x, n ):
    retval = ( x - irit.floor( x/n ) * n )
    return retval

def min( x, y ):
    if ( x > y ):
        retval = y
    else:
        retval = x
    return retval

def max( x, y ):
    if ( x > y ):
        retval = x
    else:
        retval = y
    return retval

def sqr( x ):
    retval = x * x
    return retval

def normalize( x ):
    retval = 1
    if ( irit.thisobj( "x" ) == 4 | irit.thisobj( "x" ) == 3 ):
        len = math.sqrt( x * x )
        retval = irit.point( irit.coord( x, 0 )/len, irit.coord( x, 1 )/len, irit.coord( x, 2 )/len )
        if ( irit.thisobj( "x" ) == 4 ):
            retval = irit.coerce( retval, 4 )
    if ( irit.thisobj( "return" ) == 2 ):
        irit.printf( "normalize: can handle only vectors or points, found %8.6ldgn", irit.list( x ) )
    return retval   

def midpoint( pt1, pt2 ):
    retval = ( pt1 + pt2 ) * 0.5
    return retval

def interppoint( pt1, pt2, t ):
    retval = ( pt1 * ( 1 - t ) + pt2 * t )
    return retval 

def edge2d( x1, y1, x2, y2 ):
    retval = ( irit.ctlpt( irit.E2, x1, y1 ) + \
            irit.ctlpt( irit.E2, x2, y2 ) )
    return retval

def edge3d( x1, y1, z1, x2, y2, z2 ):
    retval = ( irit.ctlpt( irit.E3, x1, y1, z1 ) + \
            irit.ctlpt( irit.E3, x2, y2, z2 ) )
    return retval

def dstptpt( pt1, pt2 ):
    retval = math.sqrt( irit.FetchRealObject( ( pt1 - pt2 ) * ( pt1 - pt2 ) ) )
    return retval

def genrandomcolor(  ):
    retval = ( str(math.floor( irit.random( 100, 255 ) ) ) + \
   "," + \
   str(math.floor( irit.random( 100, 255 ) ) ) + \
   "," + \
   str(math.floor( irit.random( 100, 255 ) ) ) )
    return retval

# 
#  Example of traversal of a list hierarchy of an object:
# 

def traverseprocessleaf( obj ):
    irit.printf( "%df\n", irit.list( obj ) )

def traverserecusrively( objlist ):
    irit.printf( "%df\n", irit.list( objlist ) )

def traverserecusrively( objlist ):
    i = 1
    while ( i <= irit.SizeOf( objlist ) ):
        obj = irit.nth( objlist, i )
        if ( irit.thisobj( "obj" ) == 10 ):
            irit.traverserecusrively( obj )
        else:
            irit.traverseprocessleaf( obj )
        i = i + 1

# 
#  Setting a fixed normal to polygonal object.
# 
def setnormalsinpoly( pl, normal ):
    retval = irit.nil(  )
    i = 0
    while ( i <= irit.SizeOf( pl ) - 1 ):
        v = irit.coord( pl, i )
        irit.attrib( v, "normal", normal )
        irit.snoc( v, retval )
        i = i + 1
    retval = irit.poly( retval, 0 )
    return retval

def setnormalsinpolyobj( obj, normal ):
    retval = irit.setnormalsinpoly( irit.coord( obj, 0 ), normal )
    i = 1
    while ( i <= irit.SizeOf( obj ) - 1 ):
        pl = irit.setnormalsinpoly( irit.coord( obj, i ), normal )
        retval = retval ^ pl
        i = i + 1
    return retval

def setnormalsinobjlist( objlist, normal ):
    retval = irit.nil(  )
    return retval

def setnormalsinobjlist( objlist, normal ):
    retval = irit.nil(  )
    i = 1
    while ( i <= irit.SizeOf( objlist ) ):
        obj = irit.nth( objlist, i )
        if ( irit.thisobj( "obj" ) == 10 ):
            irit.snoc( irit.setnormalsinobjlist( obj, normal ), retval )
        else:
            if ( irit.thisobj( "obj" ) == 1 ):
                irit.snoc( irit.setnormalsinpolyobj( obj, normal ), retval )
            else:
                irit.snoc( obj, retval )
        i = i + 1
    return retval

# 
#  Sweep of circular cross section.
# 
def swpcircsrf( axiscrv, scalecrv, scalerefine ):
    if ( type(scalecrv) == int or type(scalecrv) == float ):
        scalecrv = irit.GenRealObject(scalecrv)

    retval = irit.swpsclsrf( irit.circle( ( 0, 0, 0 ), 1 ), 
                             axiscrv, 
                             scalecrv, 
                             irit.GenIntObject(0),
                             scalerefine, 0 )
    return retval

# 
#  Example for a useful recursive function.  Such function needs to be defined
#  first as a regular function so it is known in function name-space.
# 
def processobjsmaxedgelen( obj, maxlen ):
    retval = 0
    return retval

def processobjsmaxedgelen( obj, maxlen ):
    retval = irit.nil(  )
    if ( irit.thisobj( "obj" ) == 10 ):
        i = 1
        while ( i <= irit.SizeOf( obj ) ):
            retval = retval + irit.processobjsmaxedgelen( irit.nth( obj, i ), maxlen )
            i = i + 1
    if ( irit.thisobj( "obj" ) == 1 ):
        retval = irit.list( irit.maxedgelen( irit.triangl( obj, 0 ), maxlen ) )
        irit.cpattr( irit.nref( retval, 1 ), obj )
    return retval

# 
#  Extractions of Control Polygon/Mesh/Points from a curve or a surface.
# 
def getctlpoints( crv, vecs ):
    retval = irit.nil(  )
    i = 1
    while ( i <= irit.SizeOf( crv ) ):
        if ( vecs ):
            p = irit.coerce( irit.coord( crv, i - 1 ), 4 )
        else:
            p = irit.coerce( irit.coord( crv, i - 1 ), 3 )
        irit.snoc( p, retval )
        i = i + 1
    return retval

def getctlpolygon( crv ):
    retval = irit.poly( irit.getctlpoints( crv, 0 ), 1 )
    return retval

def getctlmeshpts( srf, vecs ):
    retval = irit.nil(  )
    rsize = irit.GetMeshSize( srf, irit.ROW )
    csize = irit.GetMeshSize( srf, irit.COL )
    i = 1
    while ( i <= csize ):
        j = 1
        while ( j <= rsize ):
            if ( vecs ):
                p = irit.coerce( irit.coord( srf, ( i - 1 ) * rsize + j - 1 ), 4 )
            else:
                p = irit.coerce( irit.coord( srf, ( i - 1 ) * rsize + j - 1 ), 3 )
            irit.snoc( p, retval )
            j = j + 1
        i = i + 1
    return retval

def getctlmesh( srf ):
    first = 1
    rsize = irit.GetMeshSize( srf, 1302 )
    csize = irit.GetMeshSize( srf, 1301 )
    i = 1
    while ( i <= rsize ):
        pl = irit.nil(  )
        j = 1
        while ( j <= csize ):
            p = irit.coerce( irit.coord( srf, ( i - 1 ) * csize + j - 1 ), 4 )
            irit.snoc( p, pl )
            j = j + 1
        if ( first == 1 ):
            retval = irit.poly( pl, 1 )
            first = 0
        else:
            retval = retval + irit.poly( pl, 1 )
        i = i + 1
    j = 1
    while ( j <= csize ):
        pl = irit.nil(  )
        i = 1
        while ( i <= rsize ):
            p = irit.coerce( irit.coord( srf, ( i - 1 ) * csize + j - 1 ), 4 )
            irit.snoc( p, pl )
            i = i + 1
        retval = retval + irit.poly( pl, 1 )
        j = j + 1
    return retval

#  Orient the geometry (figure out min max domain locations).

def orientcrv( crv ):
    d = irit.pdomain( crv )
    retval = irit.list( irit.ceval( crv, irit.nth( d, 1 ) ), irit.ceval( crv, irit.nth( d, 1 ) * 0.95 + irit.nth( d, 2 ) * 0.05 ) )
    irit.color( retval, 4 )
    return retval

def orientsrf( srf ):
    d = irit.pdomain( srf )
    uisos = irit.list( irit.csurface( srf, irit.col, irit.nth( d, 1 ) ), irit.csurface( srf, irit.col, irit.nth( d, 1 ) * 0.95 + irit.nth( d, 2 ) * 0.05 ) )
    irit.color( uisos, 4 )
    visos = irit.list( irit.csurface( srf, irit.row, irit.nth( d, 3 ) ), irit.csurface( srf, irit.row, irit.nth( d, 3 ) * 0.95 + irit.nth( d, 4 ) * 0.05 ) )
    irit.color( visos, 2 )
    retval = irit.list( uisos, visos )
    return retval

#  Expects a list object of polyline objects.
def genpllnstoplgons( pl ):
    retval = irit.nil(  )
    i = 1
    while ( i <= irit.SizeOf( pl ) ):
        pl1n = irit.nil(  )
        pl1 = irit.coord( pl, i )
        j = 0
        while ( j <= irit.SizeOf( pl1 ) - 1 ):
            irit.snoc( irit.coord( pl1, j ), pl1n )
            j = j + 1
        irit.snoc( irit.coord( pl1, 0 ), pl1n )
        irit.snoc( irit.poly( pl1n, 0 ), retval )
        i = i + 1
    retval = irit.mergepoly( retval )
    return retval

#  Expects a poly object of polygons.
def genplgonstopllns( pl ):
    retval = irit.nil(  )
    i = 0
    while ( i <= irit.SizeOf( pl ) - 1 ):
        pl1n = irit.nil(  )
        pl1 = irit.coord( pl, i )
        j = 0
        while ( j <= irit.SizeOf( pl1 ) - 1 ):
            irit.snoc( irit.coord( pl1, j ), pl1n )
            j = j + 1
        irit.snoc( irit.coord( pl1, 0 ), pl1n )
        irit.snoc( irit.poly( pl1n, 1 ), retval )
        i = i + 1
    retval = irit.mergepoly( retval )
    return retval

def putcrvmarkers( crv, n, size ):
    tmin = irit.nth( irit.pdomain( crv ), 1 )
    tmax = irit.nth( irit.pdomain( crv ), 2 )
    retval = irit.nil(  )
    dt = ( tmax - tmin - 1e-006 )/float(n)
    t = tmin
    i = 0
    while ( i <= n ):
        nrml = irit.cnormal( crv, t ) * size
        pt1 = irit.coerce( irit.ceval( crv, t ), 4 ) - nrml
        pt2 = irit.coerce( irit.ceval( crv, t ), 4 ) + nrml
        irit.snoc( irit.coerce( pt1, irit.E3 ) + irit.coerce( pt2, irit.E3 ), retval )
        t = t + dt
        i = i + 1
    return retval

# 
#  Create avisual dispaly of the given knot vector KV (list of numbers).
#  VSpace controls the vertical space of identical/multiple knots.
# 
def makekvmarkers( kv, order, vspace ):
    prevt = (-1e+030 )
    prevposy = 0
    tmin = irit.nth( kv, order )
    tmax = irit.nth( kv, irit.SizeOf( kv ) - order + 1 )
    retval = irit.list( irit.ctlpt( irit.E2, tmin, 0 ) + \
                        irit.ctlpt( irit.E2, tmax, 0 ) )
    i = 1
    while ( i <= irit.SizeOf( kv ) ):
        t = irit.nth( kv, i )
        if ( irit.abs( t - prevt ) < 1e-006 ):
            posy = prevposy
        else:
            posy = vspace
        posy = posy - vspace
        irit.snoc( irit.ctlpt( irit.E2, t, posy ), retval )
        prevposy = posy
        prevt = t
        i = i + 1
    return retval


# 
#  Extract a network of isocurves.
# 
def getisocurves( srf, numu, numv ):
    retval = irit.nil(  )
    domain = irit.pdomain( srf )
    umin = irit.FetchRealObject(irit.nth( domain, 1 ))
    umax = irit.FetchRealObject(irit.nth( domain, 2 ))
    vmin = irit.FetchRealObject(irit.nth( domain, 3 ))
    vmax = irit.FetchRealObject(irit.nth( domain, 4 ))

    if ( numu > 0 ):
        i = 0
        while ( i <= numu ):
            irit.snoc( irit.csurface( srf, 1301, umin + ( umax - umin ) * i/float(numu) ), retval )
            i = i + 1
    if ( numv > 0 ):
        i = 0
        while ( i <= numv ):
            irit.snoc( irit.csurface( srf, 1302, vmin + ( vmax - vmin ) * i/float(numv) ), retval )
            i = i + 1
    return retval

def getisocurvetubes( srf, numu, numv, rad ):
    retval = irit.nil(  )
    domain = irit.pdomain( srf )
    umin = irit.FetchRealObject( irit.nth( domain, 1 ) )
    umax = irit.FetchRealObject( irit.nth( domain, 2 ) )
    vmin = irit.FetchRealObject( irit.nth( domain, 3 ) )
    vmax = irit.FetchRealObject( irit.nth( domain, 4 ) )
    i = 0
    while ( i <= numu ):
        irit.snoc( irit.swpcircsrf( irit.csurface( srf, 1301, umin + ( umax - umin ) * i/float(numu) ), rad, 1 ), retval )
        i = i + 1
    i = 0
    while ( i <= numv ):
        irit.snoc( irit.swpcircsrf( irit.csurface( srf, 1302, vmin + ( vmax - vmin ) * i/float(numv) ), rad, 1 ), retval )
        i = i + 1
    return retval

# 
#  Construct a box in the size of the bbox of an object.
# 
def createbboxbox( o ):
    b = irit.bbox( o )
    retval = irit.box( ( irit.FetchRealObject(irit.nth( b, 1 )), irit.FetchRealObject(irit.nth( b, 3 )), irit.FetchRealObject(irit.nth( b, 5 )) ), irit.FetchRealObject(irit.nth( b, 2 ) - irit.nth( b, 1 )), irit.FetchRealObject(irit.nth( b, 4 ) - irit.nth( b, 3 )), irit.FetchRealObject(irit.nth( b, 6 ) - irit.nth( b, 5 )) )
    return retval
def createbboxbox2( b ):
    retval = irit.box( (irit.FetchRealObject(irit.nth( b, 1 )), irit.FetchRealObject(irit.nth( b, 3 )), irit.FetchRealObject(irit.nth( b, 5 ))) , irit.FetchRealObject(irit.nth( b, 2 ) - irit.nth( b, 1 )) + 1e-010, irit.FetchRealObject(irit.nth( b, 4 ) - irit.nth( b, 3 )) + 1e-010, irit.FetchRealObject(irit.nth( b, 6 ) - irit.nth( b, 5 )) + 1e-010 )
    return retval

# 
#  Approximate a (assumed to be) closed planar curve as a polygon
#  with n vertices.
# 
def cnvrtcrvtopolygon( crv, n, ispolyline ):
    ptl = irit.nil(  )
    t0 = irit.FetchRealObject(irit.nth( irit.pdomain( crv ), 1 ))
    t1 = irit.FetchRealObject(irit.nth( irit.pdomain( crv ), 2 ))
    if ( n < 2 ):
        n = 2
    dt = ( t1 - t0 )/( n + 0.0001 - 1 )
    if ( ispolyline == 0 ):
        t1 = t1 - dt
    t = t0
    while ( t <= t1 ):
        pt = irit.ceval( crv, t )
        irit.snoc( pt, ptl )
        t = t + dt
    retval = irit.poly( ptl, ispolyline )
    return retval

# 
#  Convert a polygon/polyline into a list of points or a curve.
# 
def cnvrtpolytoptlist( ply ):
    retval = irit.nil(  )
    i = 0
    while ( i <= irit.SizeOf( ply ) - 1 ):
        irit.snoc( irit.coord( ply, i ), retval )
        i = i + 1
    return retval

def cnvrtpolytocrv( ply, order, kvshape ):
    retval = irit.cbspline( order, irit.cnvrtpolytoptlist( ply ), irit.list( kvshape ) )
    return retval

def cnvrtpolystocrvs( plys, order, kvshape ):
    retval = irit.nil(  )
    i = 0
    while ( i <= irit.SizeOf( plys ) - 1 ):
        ply = irit.coord( plys, i )
        irit.snoc( irit.cbspline( order, irit.cnvrtpolytoptlist( ply ), irit.list( kvshape ) ), retval )
        i = i + 1
    return retval

# 
#  Convert polynomial expressions to explicit Bezier.
# 

def cnvrtpolytotube( pl, rad, minctlpt, maxctlpt ):
    ptlist = irit.cnvrtpolytoptlist( pl )
    len = irit.SizeOf( ptlist )
    retval = irit.nil( )
    if ( len > 1 ):
        if ( len < 4 ):
            c = irit.cinterp( ptlist, len, len, irit.PARAM_UNIFORM,
                              irit.false, irit.false )
            c = irit.cinterp( ptlist, 3,
                              irit.min( irit.max( len /10.0, minctlpt ),
                                        maxctlpt ),
                              irit.PARAM_UNIFORM, irit.false,
                              irit.false )
        retval = irit.swpcircsrf( c, rad, 1 )
    return retval


def univariate2bezier( polynom, deg ):
    retval = irit.nil( )
    f = 1
    x = 0
    while ( x <= 1 ):
        exec( "f = " + polynom )
        irit.snoc( irit.ctlpt( irit.E1, f ), retval )
        x = x + 0.05 / deg    
    retval = irit.coerce( irit.cinterp( retval, deg + 1, deg + 1, 
	    irit.PARAM_UNIFORM, irit.false,
	    irit.false ), 
                          irit.BEZIER_TYPE )		 
    retval = irit.cbspline( order, irit.cnvrtpolytoptlist( ply ), irit.list( kvshape ) )
    return retval


def bivariate2bezier( polynom, xdeg, ydeg ):
    retval = irit.nil( )
    f = 1
    x = 0
    while ( x <= 1 ):
        y = 0
        while ( y <= 1):
            exec( "f = " + polynom )
            irit.snoc( irit.ctlpt( irit.E3, x, y, f ), retval )
            y = y + 0.1 / ydeg
        x = x + 0.1 / xdeg
    retval = irit.coerce( irit.sinterp( retval, 
                                        irit.list( xdeg + 1, 
                                                   ydeg + 1, 
                                                   xdeg + 1, 
                                                   ydeg + 1, 
                                                   irit.PARAM_UNIFORM ) ), 
                          irit.BEZIER_TYPE )
    return retval

# 
#  Primitives in freeform surface form.
# 

def planesrf( x1, y1, x2, y2 ):
    retval = irit.ruledsrf( irit.edge2d( x1, y1, x2, y1 ), irit.edge2d( x1, y2, x2, y2 ) )
    return retval

def spheresrf( radius ):
    s45 = math.sin( 45 * math.pi/180 )
    retval = irit.surfrev( irit.cbspline( 3, irit.list( irit.ctlpt( irit.P3, 1, 0, 0, (-1 ) ), \
                                                        irit.ctlpt( irit.P3, s45, (-s45 ), 0, (-s45 ) ), \
                                                        irit.ctlpt( irit.P3, 1, (-1 ), 0, 0 ), \
                                                        irit.ctlpt( irit.P3, s45, (-s45 ), 0, s45 ), \
                                                        irit.ctlpt( irit.P3, 1, 0, 0, 1 ) ), irit.list( 0, 0, 0, 1, 1, 2,
        2,
        2 ) ) ) * irit.scale( ( radius, radius, radius ) )
    return retval


def torussrf( mradius, mrad ):
    retval = irit.surfrev( irit.circle( ( 0, 0, 0 ), mrad ) *
                irit.trans( ( mradius, 0, 0 ) ) * irit.rotx( 90 ) )
    return retval

def conesrf( height, radius ):
    retval = irit.surfrev( irit.ctlpt( irit.E3, 0, 0, 0 ) + \
                           irit.ctlpt( irit.E3, radius, 0, 0 ) + \
                           irit.ctlpt( irit.E3, 0, 0, height ) )
    return retval

def cone2srf( height, radius1, radius2 ):
    retval = irit.surfrev( irit.ctlpt( irit.E3, 0, 0, 0 ) + \
                           irit.ctlpt( irit.E3, radius1, 0, 0 ) + \
                           irit.ctlpt( irit.E3, radius2, 0, height ) + \
                           irit.ctlpt( irit.E3, 0, 0, height ) )
    return retval

def cylinsrf( height, radius ):
    retval = irit.surfrev( irit.ctlpt( irit.E3, 0, 0, 0 ) + \
                           irit.ctlpt( irit.E3, radius, 0, 0 ) + \
                           irit.ctlpt( irit.E3, radius, 0, height ) + \
                           irit.ctlpt( irit.E3, 0, 0, height ) )
    return retval

def boxsrf( width, dpth, height ):
    retval = irit.list( irit.coerce( (-irit.planesrf( 0, 0, width, dpth ) ), irit.E3 ), irit.coerce( irit.planesrf( 0, 0, width, dpth ), irit.E3 ) * irit.trans( ( 0, 0, height ) ), irit.coerce( irit.planesrf( 0, 0, width, height ), irit.E3 ) * irit.rotx( 90 ), irit.coerce( (-irit.planesrf( 0, 0, width, height ) ), irit.E3 ) * irit.rotx( 90 ) * irit.trans( ( 0, dpth, 0 ) ), irit.coerce( irit.planesrf( 0, 0, height, dpth ), irit.E3 ) * irit.roty( (-90 ) ), irit.coerce( (-irit.planesrf( 0, 0, height, dpth ) ), irit.E3 ) * irit.roty( (-90 ) ) * irit.trans( ( width, 0, 0 ) ) )
    return retval

def flatsrf( uorder, vorder ):
    retval = irit.sbezier( irit.list( irit.list( irit.ctlpt( irit.E3, (-1 ), (-1 ), 0 ), \
                                                irit.ctlpt( irit.E3, (-1 ), 1, 0 ) ), irit.list( \
                                                irit.ctlpt( irit.E3, 1, (-1 ), 0 ), \
                                                irit.ctlpt( irit.E3, 1, 1, 0 ) ) ) )
    retval = irit.sraise( irit.sraise( retval, 1302, uorder ), 1301, vorder )
    return retval

# 
#  Domain that will be printed in A4 using a unit matrix.
# 
printablea4unitmat = irit.poly( irit.list( irit.point( (-1.1 ), (-1.22 ), 0 ), irit.point( 1.18, (-1.22 ), 0 ), irit.point( 1.18, 2.02, 0 ), irit.point( (-1.1 ), 2.02, 0 ), irit.point( (-1.1 ), (-1.22 ), 0 ) ), 1 )

# 
#  Transformations.
# 
def tx( r ):
    retval = irit.trans( ( r, 0, 0 ) )
    return retval

def ty( r ):
    retval = irit.trans( ( 0, r, 0 ) )
    return retval

def tz( r ):
    retval = irit.trans( ( 0, 0, r ) )
    return retval

def sx( r ):
    retval = irit.scale( ( r, 1, 1 ) )
    return retval

def sy( r ):
    retval = irit.scale( ( 1, r, 1 ) )
    return retval

def sz( r ):
    retval = irit.scale( ( 1, 1, r ) )
    return retval

def sc( s ):
    retval = irit.scale( ( s, s, s ) )
    return retval

def sxz( s ):
    retval = irit.sx( s ) * irit.sz( s )
    return retval

def rx( r ):
    retval = irit.rotx( r )
    return retval

def ry( r ):
    retval = irit.roty( r )
    return retval

def rz( r ):
    retval = irit.rotz( r )
    return retval

# 
#  Rotate vector w to/from Z axis
# 
#  Rotation Trans. of w dir to Z axis.
def rotvec2z( w ):
    if ( abs( irit.FetchRealObject(irit.coord( w, 0 ) ) ) > \
         abs( irit.FetchRealObject(irit.coord( w, 1 ) ) ) ):
        u = irit.vector( 0, 1, 0 )
    else:
        u = irit.vector( 1, 0, 0 )
    w = irit.normalizeVec( w )
    v = irit.normalizeVec( u ^ w )
    u = irit.normalizeVec( w ^ v )
    retval = irit.homomat( irit.list( irit.list( irit.FetchRealObject(irit.coord( u, 0 )), 
									 irit.FetchRealObject(irit.coord( v, 0 )), 
									 irit.FetchRealObject(irit.coord( w, 0 )), 
									 0 ), 
						  irit.list( irit.FetchRealObject(irit.coord( u, 1 )), 
									 irit.FetchRealObject(irit.coord( v, 1 )), 
									 irit.FetchRealObject(irit.coord( w, 1 )), 
									 0 ), 
						  irit.list( irit.FetchRealObject(irit.coord( u, 2 )), 
									 irit.FetchRealObject(irit.coord( v, 2 )), 
									 irit.FetchRealObject(irit.coord( w, 2 )), 
									 0 ), 
						  irit.list( 0, 0, 0, 1 ) ) )
    return retval

#  Rotation Trans. of Z axis to W dir.
def rotz2vec( w ):
    retval = irit.rotvec2z( w ) ^ (-1 )
    return retval

# 
#  Rotate matrix around line (Pt + t Dir), Theta degrees.
# 
def rotline( pt, dir, theta ):
    retval = irit.trans( irit.coerce( pt, 4 ) * (-1 ) ) * irit.rotvec2z( dir ) * irit.rz( theta ) * irit.rotz2vec( dir ) * irit.trans( irit.coerce( pt, 4 ) )
    return retval

# 
#  make a grid in the XY plane of n lines.
# 
def gridxy( n ):
    retval = irit.nil(  )
    i = 0
    while ( i <= n ):
        irit.snoc( irit.ctlpt( irit.e2, i/float(n), 0 ) + \
                    irit.ctlpt( irit.e2, i/float(n), 1 ), retval )
        i = i + 1
    i = 0
    while ( i <= n ):
        irit.snoc( \
                    irit.ctlpt( irit.e2, 0, i/float(n) ) + \
                    irit.ctlpt( irit.e2, 1, i/float(n) ), retval )
        i = i + 1
    retval = retval * irit.sc( 2 ) * irit.tx( (-1 ) ) * irit.ty( (-1 ) )
    return retval

def gridxyz( n ):
    g = irit.gridxy( n )
    grids = irit.nil(  )
    i = 0
    while ( i <= n ):
        irit.snoc( g * irit.tz( 2 * i/float(n) - 1 ), grids )
        i = i + 1
    retval = irit.list( grids * irit.rx( 0 ), grids * irit.rx( 90 ), grids * irit.ry( 90 ) )
    return retval

def makepolynsides( n ):
    retval = irit.nil(  )
    a = 360/float(n)
    i = 0
    while ( i <= 360 - a/2.0 ):
        irit.snoc( ( math.cos( i * math.pi/180 ), math.sin( i * math.pi/180 ), 0 ), retval )
        i = i + a
    retval = irit.poly( retval, 0 ) * irit.rz( 270 - a/2.0 )
    return retval

# 
#  A transparent grid: TranspGrid( 5, 5, 1, 5 )
# 
def transpgridaux( n, m, scl, even ):
    sqr = irit.poly( irit.list( irit.point( 0, 0, 0 ), irit.point( 0, 1, 0 ), irit.point( 1, 1, 0 ), irit.point( 1, 0, 0 ) ), 0 )
    retval = sqr
    i = (-n )
    while ( i <= n - 1 ):
        j = (-m )
        while ( j <= m - 1 ):
            if ( irit.iseven( i + j ) == even ):
                if ( retval == sqr ):
                    retval = sqr * irit.sc( scl ) * irit.tx( i * scl ) * irit.ty( j * scl )
                else:
                    retval = ( sqr * irit.sc( scl ) * irit.tx( i * scl ) * irit.ty( j * scl ) ) ^ retval
            j = j + 1
        i = i + 1
    return retval

def transpgridticks( n, m, scl, dup ):
    line = irit.poly( irit.list( irit.point( (-n ) * scl, 0, 0 ), irit.point( n * scl, 0, 0 ) ), 1 )
    lines = irit.nil(  )
    i = (-n ) * dup
    while ( i <= n * dup ):
        irit.snoc( line * irit.ty( i * scl/float(dup) ), lines )
        i = i + 1
    retval = irit.mergepoly( lines + lines * irit.rz( 90 ) )
    irit.attrib( retval, "rgb", "255,255,255" )
    return retval

def transpgrid( n, m, scl, ticks ):
    oddgrid = irit.transpgridaux( n, m, scl, 0 )
    irit.attrib( oddgrid, "rgb", "0, 0, 255" )
    irit.attrib( oddgrid, "transp", 0.01 )
    evengrid = irit.transpgridaux( n, m, scl, 1 )
    irit.attrib( evengrid, "rgb", "0, 255, 255" )
    irit.attrib( evengrid, "transp", 0.01 )
    retval = irit.list( oddgrid, evengrid )
    if ( ticks ):
        irit.snoc( irit.transpgridticks( n, m, scl, ticks ), retval )
    return retval

# 
#  Arrows.
# 
def arrow3d( pt, dir, length, width, headlength, headwidth ):
    retval = irit.list( irit.cylinsrf( length - headlength, width/2.0 ) * \
			irit.rotz2vec( dir ) * \
			irit.trans( irit.Fetch3TupleObject(irit.coerce( pt, 4 ) ) ), 
			irit.conesrf( headlength, headwidth ) * \
			irit.trans( ( 0, 0, length - headlength ) ) * \
			irit.rotz2vec( dir ) * \
			irit.trans( irit.Fetch3TupleObject(irit.coerce( pt, 4 ) ) ) )
    return retval

def curvearrowend( crv, end, headlength, headwidth ):
    tmin = irit.nth( irit.pdomain( crv ), 1 )
    tmax = irit.nth( irit.pdomain( crv ), 2 )
    if ( end ):
        pt = irit.coerce( irit.ceval( crv, tmax ), 3 )
        dir = irit.ctangent( crv, tmax, 1 )
    else:
        pt = irit.coerce( irit.ceval( crv, tmin ), 3 )
        dir = irit.ctangent( crv, tmin, 1 )
    retval = irit.conesrf( headlength, headwidth ) * irit.trans( ( 0, 0, (-headlength ) ) ) * irit.rotz2vec( dir ) * irit.trans( irit.coerce( pt, 4 ) )
    return retval

# 
#  Create random control mesh of any dimension:
# 
#  RandomControlPointRow( 3, 4, true, 0, 1); (to create 3 P4 random points).
#  RandomControlMesh( list( 2, 4 ), 3, false, -1, 1 ); ((2x4) E3 random mesh).
# 

def randomcontrolpointrow( length, numcoords, IsRational, minval, maxval ):
    retval = irit.nil(  )
    i = 1
    while ( i <= length ):
        if ( IsRational ):
            strpt = "P"
        else:
            strpt = "E"
        strpt = strpt + str(numcoords)
        if ( IsRational ):
            strpt = ( strpt + "," ) + str(irit.random( 1, 2 ))
        else:
            i = i
        j = 1
        while ( j <= numcoords ):
            strpt = ( strpt + "," ) + str(irit.random( minval, maxval ))
            j = j + 1
        exec("irit.snoc( irit.ctlpt(" + strpt + "), retval )" )
        i = i + 1
    return retval

def randomcontrolmesh( lengths, numcoords, isrational, minval, maxval ):
    retval = irit.nil(  )
    return retval

def randomcontrolmesh( lengths, numcoords, isrational, minval, maxval ):
    retval = irit.nil(  )
    dim = irit.SizeOf( lengths )
    if ( dim == 1 ):
        retval = randomcontrolpointrow( irit.FetchRealObject(irit.nth( lengths, 1 )), numcoords, isrational, minval, maxval )
    else:
        i = 1
        while ( i <= irit.FetchRealObject(irit.nth( lengths, 1 )) ):
            sublengths = irit.nil(  )
            j = 2
            while ( j <= dim ):
                irit.snoc( irit.nth( lengths, j ), sublengths )
                j = j + 1
            irit.snoc( randomcontrolmesh( sublengths, numcoords, isrational, minval, maxval ), retval )
            i = i + 1
    return retval

# 
#  Emulation of view, interact and other useful viewing functions using VIEWOBJ
#  for the default display device.
# 
#  Make some noise.
def beep(  ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject("beep")
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Clear the screen.
def viewclear(  ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject("clear")
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Delayed clear screen.
def viewdclear(  ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject("dclear")
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Disconnect from this display device
def viewdisc(  ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject("disconnect")
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Edit the specified curve.
def vieweditcrv( name ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "editcrv " + name )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Edit the specified surface.
def vieweditsrf( name ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "editsrf " + name )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Edit the specified object.
def vieweditobj( name ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "editobj " + name )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Clone & edit the specified object.
def viewcloneobj( name ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "cloneobj " + name )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Force Display device to exit.
def viewexit(  ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject("exit")
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Save viewing matrix under name.
def viewmsave( name ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "msave " + name )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Save display as image under name.
def viewimgsave( name ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "imgsave " + name )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Remove an object from display.
def viewremove( name ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "remove " + name )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Animate a sequence.
def viewanim( tmin, tmax, dt ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "animate " + str(tmin) + " " + str(tmax) + " " + str(dt) )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Change display device state.
def viewstate( state, status ):
    irit.IritDisplayDeviceActive = 1;
    command = irit.GenStrObject( "state " + state + " " + str(status) )
    irit.SetObjectName( command, "command_")
    irit.viewobj( command )

#  Emulation of old VIEW command.
def view( none, clear ):
    irit.IritDisplayDeviceActive = 1;
    if ( clear != 0 ):
        irit.viewdclear(  )
    irit.viewobj( none )

#  Emulation of old INTERACT command.
def interact( none ):
    irit.IritDisplayDeviceActive = 1;
    irit.viewdclear(  )
    irit.viewobj( none )
    irit.pause(  )

# 
#  Client communication helper functions.
# 
#  Clear the screen.
def clntclear( h ):
    command = irit.GenStrObject( "clear" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Delayed clear screen.
def clntdclear( h ):
    command = irit.GenStrObject( "dclear" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Disconnect from this display device
def clntdisc( h ):
    command = irit.GenStrObject( "disconnect" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Edit the specified curve.
def clnteditcrv( h, name ):
    command = irit.GenStrObject( "editcrv " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )
    return retval

#  Edit the specified surface.
def clnteditsrf( h, name ):
    command = irit.GenStrObject( "editsrf " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )
    return retval

#  Edit the specified object.
def clnteditobj( h, name ):
    command = irit.GenStrObject( "editobj " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Clone & edit specified object.
def clntcloneobj( h, name ):
    command = irit.GenStrObject( "cloneobj " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Force Display device to exit.
def clntexit( h ):
    command = irit.GenStrObject( "exit" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Get an object from a client.
def clntgetobj( h, name ):
    command = irit.GenStrObject( "getobj " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )
    retval = irit.clntread( h, 10000 )
    return retval

#  Get cursor events from a client.
def clntpickcrsr( h ):
    command = irit.GenStrObject( "pickcrsr" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Get an object's name from a client.
def clntpickname( h ):
    command = irit.GenStrObject( "pickname" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )
#  Pick an object from a client.

def clntpickobj( h ):
    command = irit.GenStrObject( "pickobj" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Done picking from clients.
def clntpickdone( h ):
    command = irit.GenStrObject( "pickdone" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Save viewing matrix under name.
def clntmsave( h, name ):
    command = irit.GenStrObject( "msave " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Save display as image under name.
def clntimgsave( h, name ):
    command = irit.GenStrObject( "imgsave " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Remove an object from display.
def clntremove( h, name ):
    command = irit.GenStrObject( "remove " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Animate a sequence.
def clntanim( h, tmin, tmax, dt ):
    command = irit.GenStrObject( "animate " ^ tmin ^ " " ^ tmax ^ " " ^ dt )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Change state of display device.
def clntstate( h, state ):
    command = irit.GenStrObject( "state " + state )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Emulation of old VIEW command.
def clntview( h, none, clear ):
    if ( clear != 0 ):
        irit.clntclear( h )
    irit.clntwrite( h, none )

#  Emulation of old INTERACT command.
def cntrintr( h, none ):
    irit.clntclear( h )
    irit.clntwrite( h, none )
    irit.pause(  )

#  Highlight1 object.
def clnthigh1( h, name ):
    command = irit.GenStrObject( "highlight1 " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Highlight2 object.
def clnthigh2( h, name ):
    command = irit.GenStrObject( "highlight2 " + name )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

#  Unhighlight objects.
def clntunhigh( h ):
    command = irit.GenStrObject( "unhighlight" )
    irit.SetObjectName( command, "command_")
    irit.clntwrite( h, command )

def freeuserdeffuncs( funcnamelist ):
    i = 1
    while ( i <= irit.SizeOf( funcnamelist ) ):
        irit.fnfree( irit.nth( funcnamelist, i ) )
        i = i + 1

def freealluserdeffuncs(  ):
    i = 1
    while ( i <= irit.SizeOf( usr_fn_list ) ):
        irit.fnfree( irit.nth( usr_fn_list, i ) )
        i = i + 1
    usr_fn_list = irit.nil(  )

usr_fn_list = irit.nil(  )
#  Make sure we do not delete iritinit user def funcs.

#dummy = irit.iritstate( "echosource", 1 )

i = irit.iritstate( "BspProdMethod", irit.GenRealObject( 2 ) )



